# app/services/integrations/connectors/base_connector.rb
module Integrations
  module Connectors
    class BaseConnector
      # Constantes compartidas
      REQUEST_TIMEOUT = 30.seconds

      attr_reader :config

      def initialize(config)
        @config = config
        # Las subclases pueden inicializar sus propias variables aquí
      end

      # Este es el único método público que llamarán desde fuera
      # Coordina: autenticación → fetch → retorno de datos

      def fetch_data(feature_key, from_date, to_date)
        # PASO 1: Asegurar autenticación válida
        ensure_authenticated!

        # PASO 2: Llamar al método específico según la feature
        case feature_key
        when "fuel"
          fetch_refuelings(from_date, to_date)
        when "battery"
          fetch_electric_charges(from_date, to_date)
        when "trips"
          fetch_trips(from_date, to_date)
        else
          raise ArgumentError, "Feature no soportada: #{feature_key}"
        end
      rescue AuthenticationError => e
        # Si falla autenticación, limpiar estado y re-lanzar
        Rails.logger.error("Authentication failed: #{e.message}")
        clear_authentication_state
        raise
      rescue StandardError => e
        Rails.logger.error("Error fetching data: #{e.class} - #{e.message}")
        raise ApiError, "Error obteniendo datos: #{e.message}"
      end
      # Las subclases DEBEN implementar estos métodos

      # Proceso de autenticación específico del proveedor
      # @return [Boolean] true si autenticación exitosa
      def authenticate
        raise NotImplementedError, "#{self.class} debe implementar #authenticate"
      end

      # Verificar si hay autenticación válida
      # @return [Boolean] true si está autenticado
      def authenticated?
        raise NotImplementedError, "#{self.class} debe implementar #authenticated?"
      end

      # Headers de autenticación para requests HTTP
      # @return [Hash] headers a incluir en requests
      # Puede ser vacío si el proveedor usa autenticación en el body
      def auth_headers
        {}
      end

      # Obtener repostajes en el rango de fechas
      # @param from_date [Time] fecha inicio
      # @param to_date [Time] fecha fin
      # @return [Array<Hash>] array de registros RAW del proveedor
      def fetch_refuelings(from_date, to_date)
        raise NotImplementedError, "#{self.class} debe implementar #fetch_refuelings"
      end

      # Obtener cargas eléctricas en el rango de fechas
      def fetch_electric_charges(from_date, to_date)
        raise NotImplementedError, "#{self.class} debe implementar #fetch_electric_charges"
      end

      # Obtener viajes en el rango de fechas
      def fetch_trips(from_date, to_date)
        raise NotImplementedError, "#{self.class} debe implementar #fetch_trips"
      end

      protected

      # Asegura que hay autenticación válida antes de hacer requests
      def ensure_authenticated!
        return if authenticated?

        Rails.logger.info("→ Autenticación requerida para #{self.class.name}")
        authenticate

        unless authenticated?
          raise AuthenticationError, "Falló la autenticación"
        end
      end

      # Limpiar estado de autenticación (útil cuando expira)
      def clear_authentication_state
        # Las subclases pueden sobrescribir esto para limpiar su estado
        Rails.logger.info("Clearing authentication state")
      end

      # Acceso rápido a las credenciales
      def credentials
        @config.credentials
      end

      # Realizar petición POST
      # @param url [String] URL completa del endpoint
      # @param body [Hash] datos a enviar (se convertirán a JSON)
      # @param headers [Hash] headers adicionales
      # @return [Hash] respuesta parseada como JSON
      def http_post(url, body, headers = {})
        uri = URI.parse(url)
        http = build_http_client(uri)

        request = Net::HTTP::Post.new(uri.path, default_headers.merge(headers))
        request.body = body.to_json

        log_request(:POST, url, body)

        response = http.request(request)

        log_response(response)

        parse_response(response)
      end

      # Realizar petición GET
      def http_get(url, headers = {})
        uri = URI.parse(url)
        http = build_http_client(uri)

        request = Net::HTTP::Get.new(uri.request_uri, default_headers.merge(headers))

        log_request(:GET, url, nil)

        response = http.request(request)

        log_response(response)

        parse_response(response)
      end

      private

      # Construir cliente HTTP con configuración común
      def build_http_client(uri)
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = (uri.scheme == "https")
        http.read_timeout = REQUEST_TIMEOUT
        http.open_timeout = REQUEST_TIMEOUT
        http
      end

      # Headers por defecto para todos los requests
      def default_headers
        {
          "Content-Type" => "application/json",
          "Accept" => "application/json",
          "User-Agent" => "FleetManager/1.0"
        }
      end

      # Parsear respuesta HTTP
      def parse_response(response)
        case response.code.to_i
        when 200..299
          # Respuesta exitosa
          JSON.parse(response.body)
        when 401, 403
          # Error de autenticación
          raise AuthenticationError, "Error de autenticación: #{response.body}"
        when 429
          # Rate limit
          raise RateLimitError, "Límite de peticiones excedido"
        when 500..599
          # Error del servidor
          raise ServerError, "Error del servidor (#{response.code}): #{response.body}"
        else
          # Otro error
          raise ApiError, "Error HTTP #{response.code}: #{response.body}"
        end
      rescue JSON::ParserError => e
        raise ApiError, "Respuesta no es JSON válido: #{e.message}"
      end

      # Logging de requests
      def log_request(method, url, body)
        Rails.logger.debug("→ #{self.class.name} #{method} #{url}")
        if body && body.is_a?(Hash)
          # Ocultar contraseñas en logs
          safe_body = body.deep_dup
          safe_body.dig("params", "password")&.replace("******") if safe_body.dig("params", "password")
          Rails.logger.debug("  Body: #{safe_body.to_json[0..200]}...")
        end
      end

      # Logging de responses
      def log_response(response)
        Rails.logger.debug("← Response: #{response.code}")
        Rails.logger.debug("  Body: #{response.body[0..200]}...")
      end

      class ApiError < StandardError; end
      class AuthenticationError < ApiError; end
      class RateLimitError < ApiError; end
      class ServerError < ApiError; end
    end
  end
end

# app/services/integrations/connectors/geotab_connector.rb
module Integrations
  module Connectors
    class GeotabConnector < BaseConnector
      API_BASE_URL = "https://my.geotab.com/apiv1"
      SESSION_TTL = 2.hours

      def initialize(config)
        super(config)

        # Estado de la sesión (se carga desde cache o se autentica)
        @session_id = nil
        @database = nil
        @server_path = nil
        @username = nil

        # URL dinámica (cambia después de autenticar)
        @api_url = API_BASE_URL
      end


      # Autenticación con Geotab
      # Geotab usa un sistema de sesiones:
      # 1. Envías user/pass/database
      # 2. Recibes sessionId + server path específico
      # 3. Usas ese sessionId en todos los requests siguientes
      def authenticate
        Rails.logger.info("→ Autenticando con Geotab...")

        # Construir payload de autenticación según API de Geotab
        payload = {
          method: "Authenticate",
          params: {
            userName: credentials["username"],
            password: credentials["password"],
            database: credentials["database"]
          }
        }

        begin
          # Llamar a la API de Geotab
          response = http_post(@api_url, payload)

          # Verificar respuesta exitosa
          if response["result"] && response["result"]["credentials"]
            @session_id = response["result"]["credentials"]["sessionId"]
            @database = response["result"]["credentials"]["database"]
            @user_name = response["result"]["credentials"]["userName"]

            @server_path = response["result"]["path"]

            @api_url = API_BASE_URL

            cache_session

            Rails.logger.info("✓ Geotab autenticado exitosamente")
            Rails.logger.info("  Server: #{@api_url}")
            Rails.logger.info("  Database: #{@database}")
            Rails.logger.info("  Database: #{@user_name}")
            Rails.logger.info("  Session: #{@session_id[0..10]}...")

            true
          else
            # Respuesta inválida
            Rails.logger.error("✗ Respuesta de autenticación inválida")
            raise AuthenticationError, "Respuesta de autenticación inválida"
          end

        rescue AuthenticationError
          # Re-lanzar errores de autenticación
          raise
        rescue StandardError => e
          # Capturar otros errores
          Rails.logger.error("✗ Error en autenticación Geotab: #{e.message}")
          raise AuthenticationError, "Error de conexión: #{e.message}"
        end
      end

      # Verificar si hay sesión válida
      # Intenta cargar desde cache antes de decir que no
      def authenticated?
        # Si ya tenemos sessionId en memoria, estamos autenticados
        return true if @session_id.present?

        # Intentar cargar desde cache
        load_from_cache
      end

      # Geotab no usa headers de autenticación
      # La autenticación va en el body de cada request
      def auth_headers
        {}
      end

      # OBTENCIÓN DE DATOS - REPOSTAJES (FillUp)
      def fetch_refuelings(from_date, to_date)
        Rails.logger.info("→ Obteniendo repostajes de Geotab...")
        Rails.logger.info("  Rango: #{from_date} → #{to_date}")

        # Construir payload según documentación de Geotab
        # https://geotab.github.io/sdk/software/api/reference/#Get1
        payload = {
          method: "Get",
          params: {
            # Tipo de entidad: FillUp (repostajes)
            typeName: "FillUp",

            # Búsqueda por rango de fechas
            search: {
              FromDate: format_geotab_date(from_date),
              ToDate: format_geotab_date(to_date)
            },

            # Credenciales de la sesión actual
            credentials: build_credentials
          },

          # ID único del request (para debugging)
          id: generate_request_id,

          # Versión del protocolo JSON-RPC
          jsonrpc: "2.0"
        }

        # Ejecutar request
        response = http_post(@api_url, payload)

        # Procesar respuesta de Geotab
        handle_geotab_response(response, "FillUp")
      end

      # OBTENCIÓN DE DATOS - CARGAS ELÉCTRICAS (ChargeEvent)
      def fetch_electric_charges(from_date, to_date)
        Rails.logger.info("→ Obteniendo cargas eléctricas de Geotab...")
        Rails.logger.info("  Rango: #{from_date} → #{to_date}")

        payload = {
          method: "Get",
          params: {
            # Tipo de entidad: ChargeEvent (cargas eléctricas)
            typeName: "ChargeEvent",

            search: {
              fromDate: format_geotab_date(from_date),
              toDate: format_geotab_date(to_date)
            },

            credentials: build_credentials
          },

          id: generate_request_id,
          jsonrpc: "2.0"
        }

        response = http_post(@api_url, payload)

        handle_geotab_response(response, "ChargeEvent")
      end

      # OBTENCIÓN DE DATOS - VIAJES (Trip)
      def fetch_trips(from_date, to_date)
        Rails.logger.info("→ Obteniendo viajes de Geotab...")
        Rails.logger.info("  Rango: #{from_date} → #{to_date}")

        payload = {
          method: "Get",
          params: {
            # Tipo de entidad: Trip (viajes)
            typeName: "Trip",

            search: {
              fromDate: format_geotab_date(from_date),
              toDate: format_geotab_date(to_date)
            },

            credentials: build_credentials
          },

          id: generate_request_id,
          jsonrpc: "2.0"
        }

        response = http_post(@api_url, payload)

        handle_geotab_response(response, "Trip")
      end

      protected

      # Sobrescribir para limpiar estado de Geotab
      def clear_authentication_state
        @session_id = nil
        @database = nil
        @server_path = nil
        @api_url = API_BASE_URL
        Rails.cache.delete(cache_key)

        Rails.logger.info("✓ Estado de autenticación limpiado")
      end

      private


      # Construir objeto credentials para requests
      # Geotab requiere database + sessionId en cada request
      def build_credentials
        {
          database: @database,
          userName: @user_name,
          sessionId: @session_id
        }
      end

      # Clave única para el cache de esta configuración
      def cache_key
        "geotab_session_#{@config.id}"
      end

      # Guardar sesión en cache
      def cache_session
        session_data = {
          session_id: @session_id,
          database: @database,
          server_path: @server_path
        }

        Rails.cache.write(
          cache_key,
          session_data,
          expires_in: SESSION_TTL
        )

        Rails.logger.debug("✓ Sesión cacheada (TTL: #{SESSION_TTL / 60} min)")
      end

      # Cargar sesión desde cache
      # @return [Boolean] true si se cargó exitosamente
      def load_from_cache
        cached = Rails.cache.read(cache_key)
        # Validamos que sea un Hash, si es un Array u otra cosa, lo ignoramos
        return false unless cached.is_a?(Hash)

        # Convertimos a HashWithIndifferentAccess para evitar líos de Symbol vs String
        cached = cached.with_indifferent_access

        @session_id = cached[:session_id]
        @database = cached[:database]
        @server_path = cached[:server_path]
        @api_url = API_BASE_URL

        Rails.logger.debug("✓ Sesión cargada desde cache")
        true
      end

      # Procesar respuesta de Geotab
      # Geotab usa JSON-RPC, puede retornar:
      # - { "result": [...] } → éxito
      # - { "error": { "message": "..." } } → error
      def handle_geotab_response(response, entity_type)
        # Caso 1: Error de Geotab
        if response["error"]
          error_msg = response["error"]["message"]

          # Si es error de credenciales inválidas, limpiar cache
          if error_msg.include?("Invalid credentials") ||
             error_msg.include?("session")

            Rails.logger.warn("⚠ Sesión inválida, limpiando cache...")
            clear_authentication_state

            # Re-lanzar para que el caller intente de nuevo
            raise AuthenticationError, "Sesión expirada"
          end

          # Otro tipo de error
          raise ApiError, "Geotab error: #{error_msg}"
        end

        # Caso 2: Respuesta exitosa
        result = response["result"] || []

        Rails.logger.info("✓ #{result.count} registros de #{entity_type} obtenidos")

        result
      end

      # Formatear fecha al formato ISO 8601 con milisegundos
      # Geotab requiere: "2025-01-15T10:30:00.000Z"
      def format_geotab_date(date)
        # Asegurar que sea Time
        date = Time.zone.parse(date.to_s) unless date.is_a?(Time)

        # Convertir a UTC y formatear con milisegundos
        date.utc.iso8601(3)
      end

      # Generar ID único para cada request
      # Útil para debugging y correlacionar logs
      def generate_request_id
        SecureRandom.uuid
      end
    end
  end
end

# app/services/integrations/factories/connector_factory.rb
module Integrations
  module Factories
    class ConnectorFactory
      # Construye el conector apropiado según el slug del proveedor
      #
      # @param provider_slug [String] identificador del proveedor (ej: "geotab")
      # @param config [TenantIntegrationConfiguration] configuración del tenant
      # @return [BaseConnector] instancia del conector específico
      # @raise [ArgumentError] si el proveedor no está implementado

      def self.build(provider_slug, config)
        # Validar que config sea del tipo correcto
        unless config.is_a?(TenantIntegrationConfiguration)
          raise ArgumentError, "config debe ser TenantIntegrationConfiguration"
        end

        # Validar que config esté activa
        unless config.is_active
          raise ArgumentError, "La configuración no está activa"
        end

        # Construir conector según el proveedor
        case provider_slug.to_s.downcase
        when "geotab"
          Connectors::GeotabConnector.new(config)

        when "verizon_connect"
          # TODO: Implementar en el futuro
          Connectors::VerizonConnector.new(config)

        when "tomtom_telematics"
          # TODO: Implementar en el futuro
          Connectors::TomtomConnector.new(config)

        when "samsara"
          # TODO: Implementar en el futuro
          Connectors::SamsaraConnector.new(config)

        else
          # Proveedor no soportado
          raise ArgumentError,
                "Conector no implementado para proveedor: '#{provider_slug}'. " \
                "Proveedores disponibles: #{available_providers.join(', ')}"
        end

      rescue NameError => e
        # Si la clase del conector no existe
        Rails.logger.error("Error al construir conector: #{e.message}")
        raise ArgumentError,
              "Conector para '#{provider_slug}' no está implementado aún"
      end

      # Lista de proveedores que tienen conector implementado
      # @return [Array<String>] slugs de proveedores disponibles
      def self.available_providers
        [
          "geotab"
          # "verizon_connect",  # Descomentar cuando se implemente
          # "tomtom_telematics", # Descomentar cuando se implemente
          # "samsara"            # Descomentar cuando se implemente
        ]
      end

      # Verificar si un proveedor tiene conector implementado
      # @param provider_slug [String] slug del proveedor
      # @return [Boolean] true si está disponible
      def self.provider_available?(provider_slug)
        available_providers.include?(provider_slug.to_s.downcase)
      end

      # Obtener información sobre proveedores disponibles
      # Útil para mostrar en UI o para debugging
      # @return [Hash] información de cada proveedor
      def self.providers_info
        {
          geotab: {
            name: "Geotab",
            auth_type: "session",
            features: [ "fuel", "battery", "trips" ],
            implemented: true
          },
          verizon_connect: {
            name: "Verizon Connect",
            auth_type: "token",
            features: [ "fuel", "trips" ],
            implemented: false
          },
          tomtom_telematics: {
            name: "TomTom Webfleet",
            auth_type: "basic_auth",
            features: [ "fuel", "trips" ],
            implemented: false
          },
          samsara: {
            name: "Samsara",
            auth_type: "oauth2",
            features: [ "fuel", "battery", "trips" ],
            implemented: false
          }
        }
      end
    end
  end
end

# app/services/integrations/factories/normalizer_factory.rb
module Integrations
  module Factories
    class NormalizerFactory
      def self.build(provider_slug, feature_key)
        # Construir el nombre de la clase del normalizador
        # Ejemplo: 'geotab' + 'fuel' → Integrations::Normalizers::Geotab::RefuelingNormalizer

        case provider_slug
        when "geotab"
          build_geotab_normalizer(feature_key)
        when "verizon_connect"
          build_verizon_normalizer(feature_key)
        when "tomtom_telematics"
          build_tomtom_normalizer(feature_key)
        else
          raise ArgumentError, "Normalizador no implementado para: #{provider_slug}"
        end
      end

      private

      def self.build_geotab_normalizer(feature_key)
        case feature_key
        when "fuel"
          Normalizers::Geotab::RefuelingNormalizer.new
        when "battery"
          Normalizers::Geotab::ElectricChargeNormalizer.new
        when "trips"
          Normalizers::Geotab::TripNormalizer.new
        else
          raise ArgumentError, "Feature no soportada para Geotab: #{feature_key}"
        end
      end

      def self.build_verizon_normalizer(feature_key)
        # TODO: Implementar normalizadores de Verizon
        raise NotImplementedError, "Normalizadores de Verizon pendientes"
      end

      def self.build_tomtom_normalizer(feature_key)
        # TODO: Implementar normalizadores de TomTom
        raise NotImplementedError, "Normalizadores de TomTom pendientes"
      end
    end
  end
end

# app/services/integrations/marketplace/setup_integration_service.rb
module Integrations
  module Marketplace
    class SetupIntegrationService
      # Servicio orquestador que maneja TODO el flujo de configuración
      # desde el marketplace hasta la activación final

      def initialize(tenant, provider_slug, params)
        @tenant = tenant
        @provider_slug = provider_slug
        @params = params
      end

      def call
        # PASO 1: Validar proveedor
        provider = validate_provider
        return provider unless provider.is_a?(IntegrationProvider)

        # PASO 2: Validar que el tenant no tenga ya este proveedor
        existing = check_existing_configuration(provider)
        return existing if existing.failure?

        # PASO 3: Validar estructura de credenciales
        validation = validate_credentials_structure(provider)
        return validation if validation.failure?

        # PASO 4: (OPCIONAL) Probar conexión si se solicita
        if @params[:test_connection_first]
          connection_test = test_connection_before_create(provider)
          return connection_test if connection_test.failure?
        end

        # PASO 5: Crear configuración (inactiva)
        config = create_configuration(provider)
        return config if config.failure?

        # PASO 6: (OPCIONAL) Activar inmediatamente si se solicita
        if @params[:activate_immediately]
          activation = activate_configuration(config.data)
          return activation if activation.failure?
        end

        # PASO 7: Retornar resultado exitoso
        ServiceResult.success(
          data: config.data,
          message: build_success_message(config.data)
        )

      rescue StandardError => e
        Rails.logger.error("Error en SetupIntegrationService: #{e.message}")
        ServiceResult.failure(
          errors: [ "Error al configurar integración: #{e.message}" ]
        )
      end

      private

      # ======================================================================
      # PASO 1: Validar Proveedor
      # ======================================================================
      def validate_provider
        provider = IntegrationProvider.for_marketplace.find_by(slug: @provider_slug)

        unless provider
          return ServiceResult.failure(
            errors: [ "Proveedor '#{@provider_slug}' no encontrado o no disponible" ]
          )
        end

        unless provider.integration_auth_schema&.is_active
          return ServiceResult.failure(
            errors: [ "El proveedor no tiene configuración de autenticación disponible" ]
          )
        end

        provider
      end

      # ======================================================================
      # PASO 2: Verificar Configuración Existente
      # ======================================================================
      def check_existing_configuration(provider)
        existing = @tenant.tenant_integration_configurations.find_by(
          integration_provider: provider
        )

        if existing
          return ServiceResult.failure(
            errors: [ "Ya existe una configuración para este proveedor" ],
            data: { existing_configuration_id: existing.id }
          )
        end

        ServiceResult.success
      end

      # ======================================================================
      # PASO 3: Validar Credenciales
      # ======================================================================
      def validate_credentials_structure(provider)
        credentials = @params[:credentials]

        unless credentials.is_a?(Hash) && credentials.present?
          return ServiceResult.failure(
            errors: [ "Las credenciales son requeridas" ]
          )
        end

        schema = provider.integration_auth_schema
        required_fields = schema.required_fields.map { |f| f["name"] }
        provided_fields = credentials.keys.map(&:to_s)

        missing_fields = required_fields - provided_fields

        if missing_fields.any?
          return ServiceResult.failure(
            errors: [ "Faltan campos requeridos: #{missing_fields.join(', ')}" ]
          )
        end

        ServiceResult.success
      end

      # ======================================================================
      # PASO 4: Test de Conexión (Opcional)
      # ======================================================================
      def test_connection_before_create(provider)
        Rails.logger.info("→ Probando conexión antes de crear configuración...")

        result = TenantConfigurations::TestConnectionService.new(
          provider.id,
          @params[:credentials]
        ).call

        unless result.success?
          return ServiceResult.failure(
            errors: [ "Test de conexión falló: #{result.errors.join(', ')}" ]
          )
        end

        Rails.logger.info("✓ Test de conexión exitoso")
        ServiceResult.success
      end

      # ======================================================================
      # PASO 5: Crear Configuración
      # ======================================================================
      def create_configuration(provider)
        config = @tenant.tenant_integration_configurations.build(
          integration_provider: provider,
          credentials: @params[:credentials],
          enabled_features: @params[:enabled_features] || [],
          sync_frequency: @params[:sync_frequency] || "daily",
          sync_hour: @params[:sync_hour] || 2,
          sync_day_of_week: @params[:sync_day_of_week],
          sync_day_of_month: @params[:sync_day_of_month],
          sync_config: @params[:sync_config] || {},
          is_active: false # Siempre empieza inactiva
        )

        if config.save
          Rails.logger.info("✓ Configuración creada (ID: #{config.id})")
          ServiceResult.success(data: config)
        else
          ServiceResult.failure(
            errors: config.errors.full_messages
          )
        end
      end

      # ======================================================================
      # PASO 6: Activar Configuración (Opcional)
      # ======================================================================
      def activate_configuration(config)
        # Validar que tenga al menos una feature habilitada
        unless config.enabled_features.any?
          return ServiceResult.failure(
            errors: [ "Debe seleccionar al menos una funcionalidad antes de activar" ]
          )
        end

        if config.update(is_active: true, activated_at: Time.current)
          Rails.logger.info("✓ Configuración activada")
          ServiceResult.success(data: config)
        else
          ServiceResult.failure(
            errors: config.errors.full_messages
          )
        end
      end

       def build_success_message(config)
        base = "Integración con #{config.integration_provider.name} configurada exitosamente"

        if config.is_active
          "#{base} y activada"
        else
          "#{base}. Recuerda activarla para comenzar a sincronizar"
        end
      end
    end
  end
end

# app/services/integrations/marketplace/unified_marketplace_service.rb
module Integrations
  module Marketplace
    class UnifiedMarketplaceService
      def initialize(filters = {})
        @view = filters[:view] || "grouped"
        @category_slug = filters[:category_slug]
        @provider_status = filters[:provider_status]
        @is_premium = filters[:is_premium]
        @search = filters[:search]
        @include_features = filters[:include_features]
        @include_auth_info = filters[:include_auth_info]
        @include_stats = filters[:include_stats]
      end

      def call
        case @view
        when "grouped"
          get_grouped_marketplace
        when "flat"
          get_flat_marketplace
        when "category_detail"
          get_category_detail
        else
          ServiceResult.failure(errors: [ "Vista no válida: #{@view}" ])
        end
      rescue StandardError => e
        Rails.logger.error("Error en UnifiedMarketplaceService: #{e.message}")
        ServiceResult.failure(errors: [ "Error al cargar el marketplace: #{e.message}" ])
      end

      private

      def get_grouped_marketplace
        # Obtener categorías activas
        categories = IntegrationCategory.active.ordered

        # Aplicar filtro de categoría específica si existe
        categories = categories.where(slug: @category_slug) if @category_slug.present?

        # Aplicar búsqueda
        categories = apply_search_to_categories(categories) if @search.present?

        # Precargar relaciones
        categories = categories.includes(
          integration_providers: [ :integration_features, :integration_auth_schema ]
        )

        # Filtrar proveedores dentro de cada categoría
        categories_data = categories.map do |category|
          providers = filter_providers(category.integration_providers.for_marketplace)

          # Solo incluir categorías que tienen proveedores después del filtrado
          next if providers.empty?

          {
            category: category,
            providers: providers
          }
        end.compact

        ServiceResult.success(
          data: {
            categories: categories_data.map { |c| c[:category] },
            total_categories: categories_data.count,
            total_providers: categories_data.sum { |c| c[:providers].count }
          }
        )
      end

      def get_flat_marketplace
        # Obtener todos los proveedores activos
        providers = IntegrationProvider.for_marketplace

        # Filtrar por categoría
        if @category_slug.present?
          category = IntegrationCategory.find_by(slug: @category_slug)
          providers = providers.where(integration_category: category) if category
        end

        # Aplicar filtros
        providers = filter_providers(providers)

        # Aplicar búsqueda
        providers = apply_search_to_providers(providers) if @search.present?

        # Precargar relaciones
        providers = providers.includes(
          :integration_category,
          :integration_features,
          :integration_auth_schema
        )

        ServiceResult.success(
          data: {
            providers: providers,
            total_providers: providers.count,
            filters_applied: active_filters
          }
        )
      end

      def get_category_detail
        unless @category_slug.present?
          return ServiceResult.failure(
            errors: [ "Se requiere 'category_slug' para la vista category_detail" ]
          )
        end

        category = IntegrationCategory
          .active
          .includes(integration_providers: [ :integration_features, :integration_auth_schema ])
          .find_by(slug: @category_slug)

        unless category
          return ServiceResult.failure(
            errors: [ "Categoría '#{@category_slug}' no encontrada" ]
          )
        end

        # Filtrar proveedores
        providers = filter_providers(category.integration_providers.for_marketplace)

        ServiceResult.success(
          data: {
            category: category,
            providers: providers,
            providers_count: providers.count
          }
        )
      end

      def filter_providers(providers)
        # Filtrar por estado
        if @provider_status.present?
          providers = providers.where(status: @provider_status)
        end

        # Filtrar por premium
        unless @is_premium.nil?
          providers = providers.where(is_premium: @is_premium)
        end

        providers
      end

      def apply_search_to_providers(providers)
        search_term = "%#{@search}%"
        providers.where(
          "integration_providers.name ILIKE :term OR integration_providers.description ILIKE :term",
          term: search_term
        )
      end

      def apply_search_to_categories(categories)
        search_term = "%#{@search}%"
        categories.where(
          "integration_categories.name ILIKE :term OR integration_categories.description ILIKE :term",
          term: search_term
        )
      end

      def active_filters
        {
          view: @view,
          category_slug: @category_slug,
          provider_status: @provider_status,
          is_premium: @is_premium,
          search: @search
        }.compact
      end
    end
  end
end

# app/services/integrations/normalizers/geotab/electric_charge_normalizer.rb
module Integrations
  module Normalizers
    module Geotab
      class ElectricChargeNormalizer < BaseNormalizer
        REQUIRED_FIELDS = %w[startTime duration device.id].freeze

        def normalize(raw_data, config)
          validate_required_fields(raw_data, REQUIRED_FIELDS)

          data = extract_charge_data(raw_data, config)
          charge = create_charge_record(data, raw_data, config)

          ServiceResult.success(data: charge)
        rescue StandardError => e
          ServiceResult.failure(errors: [ e.message ])
        end

        private

        def extract_charge_data(raw_data, config)
          external_vehicle_id = extract_field(raw_data, "device.id")
          vehicle = map_vehicle(external_vehicle_id, config)

          start_time = parse_date(extract_field(raw_data, "startTime"))
          duration_str = extract_field(raw_data, "duration") # "03:28:33.258"
          duration_minutes = parse_duration_to_minutes(duration_str)

          {
            vehicle: vehicle,
            charge_start_time: start_time,
            charge_end_time: start_time + duration_minutes.minutes,
            duration_minutes: duration_minutes,
            location_lat: extract_field(raw_data, "location.y"),
            location_lng: extract_field(raw_data, "location.x"),
            charge_type: extract_field(raw_data, "chargeType"),
            start_soc_percent: extract_field(raw_data, "startStateOfCharge")&.to_f,
            end_soc_percent: extract_field(raw_data, "endStateOfCharge")&.to_f,
            energy_consumed_kwh: extract_field(raw_data, "energyConsumedKwh")&.to_f,
            peak_power_kw: extract_field(raw_data, "peakPowerKw")&.to_f,
            odometer_km: convert_to_km(extract_field(raw_data, "chargingStartedOdometerKm")),
            is_estimated: extract_field(raw_data, "chargeIsEstimated") || false,
            max_ac_voltage: extract_field(raw_data, "maxACVoltage")&.to_i,
            provider_metadata: build_metadata(raw_data)
          }
        end

        def create_charge_record(data, raw_data, config)
          VehicleElectricCharge.create!(
            tenant: config.tenant,
            vehicle: data[:vehicle],
            integration_raw_data: raw_data,
            charge_start_time: data[:charge_start_time],
            charge_end_time: data[:charge_end_time],
            duration_minutes: data[:duration_minutes],
            location_lat: data[:location_lat],
            location_lng: data[:location_lng],
            charge_type: data[:charge_type],
            start_soc_percent: data[:start_soc_percent],
            end_soc_percent: data[:end_soc_percent],
            energy_consumed_kwh: data[:energy_consumed_kwh],
            peak_power_kw: data[:peak_power_kw],
            odometer_km: data[:odometer_km],
            is_estimated: data[:is_estimated],
            max_ac_voltage: data[:max_ac_voltage],
            provider_metadata: data[:provider_metadata]
          )
        end

        def parse_duration_to_minutes(duration_str)
          # "03:28:33.258" → 208 minutos
          return nil if duration_str.blank?

          parts = duration_str.split(":")
          hours = parts[0].to_i
          minutes = parts[1].to_i

          (hours * 60) + minutes
        end

        def convert_to_km(value)
          value&.to_f
        end

        def build_metadata(raw_data)
          {
            measured_onboard_charger_energy_in: extract_field(raw_data, "measuredOnBoardChargerEnergyInKwh"),
            measured_battery_energy_in: extract_field(raw_data, "measuredBatteryEnergyInKwh"),
            version: extract_field(raw_data, "version")
          }.compact
        end
      end
    end
  end
end

# app/services/integrations/normalizers/geotab/refueling_normalizer.rb
module Integrations
  module Normalizers
    module Geotab
      class RefuelingNormalizer < BaseNormalizer
        # Campos requeridos en el JSON de Geotab
        REQUIRED_FIELDS = %w[dateTime volume device.id].freeze

        def normalize(raw_data, config)
          # PASO 1: Validar campos requeridos
          validate_required_fields(raw_data, REQUIRED_FIELDS)

          # PASO 2: Extraer datos del JSON RAW
          data = extract_refueling_data(raw_data, config)

          # PASO 3: Crear registro en VehicleRefueling
          refueling = create_refueling_record(data, raw_data, config)

          ServiceResult.success(
            data: refueling,
            message: "Repostaje normalizado exitosamente"
          )

        rescue StandardError => e
          ServiceResult.failure(errors: [ e.message ])
        end

        private

        # ========================================================================
        # EXTRAER DATOS
        # ========================================================================

        def extract_refueling_data(raw_data, config)
          # Extraer external_vehicle_id
          external_vehicle_id = extract_field(raw_data, "device.id")

          # Mapear a vehicle de nuestra BD
          vehicle = map_vehicle(external_vehicle_id, config)

          # Extraer campos del JSON
          {
            vehicle: vehicle,
            refueling_date: parse_date(extract_field(raw_data, "dateTime")),
            volume_liters: extract_field(raw_data, "volume")&.to_f,
            cost: extract_field(raw_data, "cost")&.to_f,
            currency: extract_field(raw_data, "currencyCode")&.strip,
            odometer_km: convert_to_km(extract_field(raw_data, "odometer")),
            location_lat: extract_field(raw_data, "location.y"),
            location_lng: extract_field(raw_data, "location.x"),
            fuel_type: extract_field(raw_data, "productType") || "Unknown",
            confidence_level: extract_field(raw_data, "confidence"),
            is_estimated: false, # Geotab marca FillUp como medido
            tank_capacity_liters: extract_tank_capacity(raw_data),
            provider_metadata: build_metadata(raw_data)
          }
        end

        # ========================================================================
        # CREAR REGISTRO
        # ========================================================================

        def create_refueling_record(data, raw_data, config)
          VehicleRefueling.create!(
            tenant: config.tenant,
            vehicle: data[:vehicle],
            integration_raw_data: raw_data,
            refueling_date: data[:refueling_date],
            volume_liters: data[:volume_liters],
            cost: data[:cost],
            currency: data[:currency],
            odometer_km: data[:odometer_km],
            location_lat: data[:location_lat],
            location_lng: data[:location_lng],
            fuel_type: data[:fuel_type],
            confidence_level: data[:confidence_level],
            is_estimated: data[:is_estimated],
            tank_capacity_liters: data[:tank_capacity_liters],
            provider_metadata: data[:provider_metadata]
          )
        end

        # ========================================================================
        # UTILIDADES ESPECÍFICAS DE GEOTAB
        # ========================================================================

        def convert_to_km(odometer_value)
          return nil if odometer_value.nil?
          # Geotab devuelve odómetro en metros, convertir a km
          (odometer_value.to_f / 1000).round(2)
        end

        def extract_tank_capacity(raw_data)
          capacity = extract_field(raw_data, "tankCapacity.volume")
          capacity&.to_f
        end

        def build_metadata(raw_data)
          {
            distance: extract_field(raw_data, "distance"),
            total_fuel_used: extract_field(raw_data, "totalFuelUsed"),
            derived_volume: extract_field(raw_data, "derivedVolume"),
            version: extract_field(raw_data, "version")
          }.compact
        end
      end
    end
  end
end

# app/services/integrations/normalizers/base_normalizer.rb
module Integrations
  module Normalizers
    class BaseNormalizer
      # Método principal que debe implementar cada normalizador
      def normalize(raw_data, config)
        raise NotImplementedError, "Subclases deben implementar #normalize"
      end

      protected

      # ========================================================================
      # MÉTODOS AUXILIARES COMPARTIDOS
      # ========================================================================

      # Mapear external_vehicle_id a vehicle_id de nuestra BD
      def map_vehicle(external_vehicle_id, config)
        mapping = VehicleProviderMapping.find_by(
          tenant_integration_configuration: config,
          external_vehicle_id: external_vehicle_id,
          is_active: true
        )

        unless mapping
          raise "Vehicle mapping not found for external_id: #{external_vehicle_id}"
        end

        mapping.vehicle
      end

      # Extraer valor de un campo del raw_data
      def extract_field(raw_data, field_path)
        # Soporta paths anidados: 'device.id', 'location.x'
        fields = field_path.split(".")
        value = raw_data.raw_data

        fields.each do |field|
          value = value[field] || value[field.to_sym]
          return nil if value.nil?
        end

        value
      end

      # Parsear fecha del proveedor
      def parse_date(date_string)
        return nil if date_string.blank?
        Time.zone.parse(date_string)
      rescue ArgumentError => e
        Rails.logger.warn("Error al parsear fecha '#{date_string}': #{e.message}")
        nil
      end

      # Validar que campos requeridos existan
      def validate_required_fields(raw_data, required_fields)
        missing = required_fields.select { |field| extract_field(raw_data, field).nil? }

        if missing.any?
          raise "Campos requeridos faltantes: #{missing.join(', ')}"
        end
      end
    end
  end
end

# app/services/integrations/normalizers/normalize_data_service.rb
module Integrations
  module Normalizers
    class NormalizeDataService
      def initialize(execution, config)
        @execution = execution
        @config = config
        @feature_key = execution.feature_key
      end

      def call
        # PASO 1: Obtener registros RAW pendientes de normalizar
        pending_records = @execution.integration_raw_data.pending

        if pending_records.empty?
          return ServiceResult.success(
            data: { processed: 0, failed: 0 },
            message: "No hay registros pendientes de normalizar"
          )
        end

        Rails.logger.info("→ Normalizando #{pending_records.count} registros...")

        # PASO 2: Obtener el normalizador apropiado
        normalizer = get_normalizer

        # PASO 3: Procesar cada registro
        stats = process_records(pending_records, normalizer)

        # PASO 4: Retornar resultado
        ServiceResult.success(
          data: stats,
          message: "#{stats[:processed]} registros normalizados"
        )

      rescue StandardError => e
        Rails.logger.error("Error en NormalizeDataService: #{e.message}")
        ServiceResult.failure(errors: [ e.message ])
      end

      private

      # ========================================================================
      # OBTENER NORMALIZADOR
      # ========================================================================

      def get_normalizer
        Factories::NormalizerFactory.build(
          @config.integration_provider.slug,
          @feature_key
        )
      end

      # ========================================================================
      # PROCESAR REGISTROS
      # ========================================================================

      def process_records(pending_records, normalizer)
        processed = 0
        failed = 0

        pending_records.each do |raw_data|
          begin
            # Normalizar el registro
            result = normalizer.normalize(raw_data, @config)

            if result.success?
              # Éxito: marcar como normalizado y asociar al registro final
              raw_data.mark_as_normalized!(result.data)
              processed += 1
              Rails.logger.debug("  ✓ Normalizado: #{raw_data.external_id}")
            else
              # Fallo: marcar como fallido con el error
              error_message = result.errors.join(", ")
              raw_data.mark_as_failed!(error_message)
              failed += 1
              Rails.logger.warn("  ✗ Falló: #{raw_data.external_id} - #{error_message}")
            end

          rescue StandardError => e
            # Error inesperado: marcar como fallido
            raw_data.mark_as_failed!("Error inesperado: #{e.message}")
            failed += 1
            Rails.logger.error("  ✗ Error: #{raw_data.external_id} - #{e.message}")
          end
        end

        Rails.logger.info("✓ Normalización completada:")
        Rails.logger.info("  - Procesados: #{processed}")
        Rails.logger.info("  - Fallidos: #{failed}")

        { processed: processed, failed: failed }
      end
    end
  end
end

# app/services/integrations/sync/sync_execution_service.rb
module Integrations
  module Sync
    class SyncExecutionService
      # Este servicio coordina el proceso completo:
      # 1. Validar que se puede sincronizar
      # 2. Crear registro de ejecución
      # 3. Obtener datos RAW del proveedor (vía connector)
      # 4. Guardar datos RAW
      # 5. Normalizar datos RAW
      # 6. Actualizar estadísticas

      attr_reader :config, :feature_key, :execution, :connector

      def initialize(config, feature_key, manual: true)
        @config = config
        @feature_key = feature_key
        @trigger_type = manual ? "manual" : "scheduled"
        @execution = nil
        @connector = nil
      end


      def call
        # PASO 1: Validaciones previas
        return validation_error unless valid_configuration?

        # PASO 2: Crear registro de ejecución
        create_execution_record

        # PASO 3: Ejecutar sincronización (con manejo de errores)
        begin
          execute_sync_process
          complete_execution
          update_configuration_status

          # Retornar resultado exitoso
          ServiceResult.success(
            data: build_success_response,
            message: "Sincronización completada exitosamente"
          )

        rescue StandardError => e
          # Si algo falla, marcar como fallida y retornar error
          handle_execution_error(e)

          ServiceResult.failure(
            errors: [ e.message ],
            data: { execution_id: @execution&.id }
          )
        end
      end

      private

      # ====================================================================
      # PASO 1: VALIDACIONES
      # ====================================================================

      def valid_configuration?
        # Verificar que la configuración esté activa
        return false unless @config.is_active

        # Verificar que la feature esté habilitada
        return false unless @config.enabled_features.include?(@feature_key)

        # Verificar que tenga credenciales
        return false unless @config.credentials.present?

        # Verificar que el conector esté disponible
        return false unless Factories::ConnectorFactory.provider_available?(@config.integration_provider.slug)

        true
      end

      def validation_error
        errors = []

        unless @config.is_active
          errors << "La configuración no está activa"
        end

        unless @config.enabled_features.include?(@feature_key)
          errors << "La feature '#{@feature_key}' no está habilitada"
        end

        unless @config.credentials.present?
          errors << "No hay credenciales configuradas"
        end

        unless Factories::ConnectorFactory.provider_available?(@config.integration_provider.slug)
          errors << "El proveedor no tiene conector implementado"
        end

        ServiceResult.failure(errors: errors)
      end

      # ====================================================================
      # PASO 2: CREAR REGISTRO DE EJECUCIÓN
      # ====================================================================

      def create_execution_record
        @execution = @config.integration_sync_executions.create!(
          feature_key: @feature_key,
          trigger_type: @trigger_type,
          status: "running",
          started_at: Time.current,
          metadata: {
            date_range: calculate_date_range,
            provider_slug: @config.integration_provider.slug,
            provider_name: @config.integration_provider.name
          }
        )

        Rails.logger.info("=" * 70)
        Rails.logger.info("🚀 Iniciando sincronización ##{@execution.id}")
        Rails.logger.info("   Proveedor: #{@config.integration_provider.name}")
        Rails.logger.info("   Feature: #{@feature_key}")
        Rails.logger.info("   Trigger: #{@trigger_type}")
        Rails.logger.info("=" * 70)
      end

      # ====================================================================
      # PASO 3: PROCESO DE SINCRONIZACIÓN
      # ====================================================================

      def execute_sync_process
        # PASO 3.1: Obtener conector
        # El connector ya maneja su propia autenticación internamente
        build_connector

        # PASO 3.2: Obtener datos RAW del proveedor
        fetch_raw_data

        # PASO 3.3: Normalizar datos RAW a modelos internos
        normalize_data
      end

      # ----------------------------------------------------------------------
      # PASO 3.1: Construir Connector
      # ----------------------------------------------------------------------

      def build_connector
        Rails.logger.info("→ Construyendo connector...")

        @connector = Factories::ConnectorFactory.build(
          @config.integration_provider.slug,
          @config
        )

        Rails.logger.info("✓ Connector #{@connector.class.name} construido")
      end

      # ----------------------------------------------------------------------
      # PASO 3.2: Obtener Datos RAW
      # ----------------------------------------------------------------------

      def fetch_raw_data
        Rails.logger.info("→ Obteniendo datos RAW del proveedor...")

        # Calcular rango de fechas
        date_range = calculate_date_range

        Rails.logger.info("   Desde: #{date_range[:from]}")
        Rails.logger.info("   Hasta: #{date_range[:to]}")

        # El connector maneja autenticación automáticamente
        # Si la sesión expiró, re-autentica transparentemente
        raw_response = @connector.fetch_data(
          @feature_key,
          date_range[:from],
          date_range[:to]
        )

        # Guardar registros RAW en BD
        stats = save_raw_data(raw_response)

        Rails.logger.info("✓ Datos RAW obtenidos:")
        Rails.logger.info("   Nuevos: #{stats[:created]}")
        Rails.logger.info("   Duplicados: #{stats[:duplicates]}")

      rescue Connectors::BaseConnector::AuthenticationError => e
        # Error de autenticación
        raise "Error de autenticación con #{@config.integration_provider.name}: #{e.message}"

      rescue Connectors::BaseConnector::RateLimitError => e
        # Rate limit excedido
        raise "Límite de peticiones excedido. Intente más tarde."

      rescue Connectors::BaseConnector::ServerError => e
        # Error del servidor del proveedor
        raise "Error del servidor de #{@config.integration_provider.name}: #{e.message}"

      rescue StandardError => e
        # Otro error
        raise "Error al obtener datos: #{e.message}"
      end

      def save_raw_data(raw_response)
        created_count = 0
        duplicates_count = 0

        # raw_response es un Array de Hashes
        raw_response.each do |record|
          # Extraer ID único del proveedor
          external_id = extract_external_id(record)

          # Crear o detectar duplicado
          raw_data = IntegrationRawData.create_or_mark_duplicate(
            integration_sync_execution: @execution,
            tenant_integration_configuration: @config,
            provider_slug: @config.integration_provider.slug,
            feature_key: @feature_key,
            external_id: external_id,
            raw_data: record,
            processing_status: "pending"
          )

          if raw_data.duplicate?
            duplicates_count += 1
            Rails.logger.debug("  ⊘ Duplicado: #{external_id}")
          else
            created_count += 1
            Rails.logger.debug("  ✓ Nuevo: #{external_id}")
          end
        end

        { created: created_count, duplicates: duplicates_count }
      end

      def extract_external_id(record)
        # El ID del registro en el proveedor
        # Geotab usa campo "id"
        record["id"] || record[:id] || raise("Registro sin ID: #{record.inspect}")
      end

      # ----------------------------------------------------------------------
      # PASO 3.3: Normalizar Datos
      # ----------------------------------------------------------------------

      def normalize_data
        Rails.logger.info("→ Normalizando datos...")

        # Delegar al servicio de normalización
        result = Normalizers::NormalizeDataService.new(
          @execution,
          @config
        ).call

        if result.success?
          stats = result.data
          Rails.logger.info("✓ Normalización completada:")
          Rails.logger.info("   Procesados: #{stats[:processed]}")
          Rails.logger.info("   Fallidos: #{stats[:failed]}")
        else
          Rails.logger.warn("⚠ Normalización con errores: #{result.errors.join(', ')}")
        end
      end

      # ====================================================================
      # PASO 4: COMPLETAR EJECUCIÓN
      # ====================================================================

      def complete_execution
        # Calcular estadísticas finales
        stats = calculate_statistics

        # Actualizar registro de ejecución
        @execution.update!(
          status: "completed",
          finished_at: Time.current,
          duration_seconds: (Time.current - @execution.started_at).to_i,
          records_fetched: stats[:fetched],
          records_processed: stats[:processed],
          records_failed: stats[:failed],
          records_skipped: stats[:skipped]
        )

        Rails.logger.info("=" * 70)
        Rails.logger.info("✅ Sincronización ##{@execution.id} completada")
        Rails.logger.info("   Duración: #{@execution.duration_seconds}s")
        Rails.logger.info("   Tasa de éxito: #{@execution.success_rate}%")
        Rails.logger.info("=" * 70)
      end

      def calculate_statistics
        raw_data = @execution.integration_raw_data

        {
          fetched: raw_data.count,
          processed: raw_data.normalized.count,
          failed: raw_data.failed.count,
          skipped: raw_data.duplicate.count
        }
      end

      # ====================================================================
      # PASO 5: ACTUALIZAR CONFIGURACIÓN
      # ====================================================================

      def update_configuration_status
        @config.update!(
          last_sync_at: Time.current,
          last_sync_status: "success",
          last_sync_error: nil
        )
      end

      # ====================================================================
      # MANEJO DE ERRORES
      # ====================================================================

      def handle_execution_error(error)
        Rails.logger.error("=" * 70)
        Rails.logger.error("❌ Error en sincronización ##{@execution&.id}")
        Rails.logger.error("   Mensaje: #{error.message}")
        Rails.logger.error("   Tipo: #{error.class.name}")
        Rails.logger.error("=" * 70)
        Rails.logger.error(error.backtrace.join("\n"))

        if @execution
          @execution.update!(
            status: "failed",
            finished_at: Time.current,
            duration_seconds: (Time.current - @execution.started_at).to_i,
            error_message: error.message
          )
        end

        @config.update!(
          last_sync_at: Time.current,
          last_sync_status: "error",
          last_sync_error: error.message
        )
      end

      # ====================================================================
      # UTILIDADES
      # ====================================================================

      def calculate_date_range
        # Estrategia de sincronización:
        # - Primera sync: últimos 30 días
        # - Incremental: desde última exitosa (con overlap de 2h)

        if first_sync?
          {
            from: 30.days.ago.beginning_of_day,
            to: Time.current,
            strategy: :initial
          }
        else
          {
            from: @config.last_sync_at - 2.hours, # Overlap para evitar gaps
            to: Time.current,
            strategy: :incremental
          }
        end
      end

      def first_sync?
        @config.last_sync_at.nil? || @config.last_sync_status != "success"
      end

      def build_success_response
        {
          execution_id: @execution.id,
          feature_key: @feature_key,
          provider_name: @config.integration_provider.name,
          records_fetched: @execution.records_fetched,
          records_processed: @execution.records_processed,
          records_failed: @execution.records_failed,
          records_skipped: @execution.records_skipped,
          duration_seconds: @execution.duration_seconds,
          success_rate: @execution.success_rate,
          started_at: @execution.started_at,
          finished_at: @execution.finished_at,
          warnings: build_warnings
        }
      end

      def build_warnings
        warnings = []

        if @execution.records_failed > 0
          warnings << "#{@execution.records_failed} registros fallaron al normalizar"
        end

        if @execution.records_skipped > 0
          warnings << "#{@execution.records_skipped} registros duplicados omitidos"
        end

        warnings
      end
    end
  end
end

# app/services/integrations/tenant_configurations/activate_service.rb
module Integrations
  module TenantConfigurations
    class ActivateService
      def initialize(config)
        @config = config
      end

      def call
        # Validar que tenga credenciales
        unless @config.credentials.present?
          return ServiceResult.failure(
            errors: [ "Debe configurar las credenciales antes de activar" ]
          )
        end

        # Validar que tenga al menos una feature habilitada
        unless @config.enabled_features.any?
          return ServiceResult.failure(
            errors: [ "Debe seleccionar al menos una funcionalidad a sincronizar" ]
          )
        end

        if @config.activate!
          ServiceResult.success(
            data: @config,
            message: "Configuración activada exitosamente"
          )
        else
          ServiceResult.failure(errors: @config.errors.full_messages)
        end
      rescue StandardError => e
        Rails.logger.error("Error al activar configuración: #{e.message}")
        ServiceResult.failure(errors: [ "Error al activar la configuración" ])
      end
    end
  end
end

# app/services/integrations/tenant_configurations/create_service.rb
module Integrations
  module TenantConfigurations
    class CreateService
      def initialize(tenant, params)
        @tenant = tenant
        @params = params
      end

      def call
        # Verificar que el proveedor existe y está disponible
        provider = IntegrationProvider.for_marketplace.find_by(id: @params[:integration_provider_id])
        unless provider
          return ServiceResult.failure(errors: [ "Proveedor no encontrado o no disponible" ])
        end

        # Verificar que no exista ya una configuración para este proveedor
        existing = @tenant.tenant_integration_configurations
          .find_by(integration_provider_id: provider.id)

        if existing
          return ServiceResult.failure(
            errors: [ "Ya existe una configuración para este proveedor" ]
          )
        end

        # Crear configuración
        config = @tenant.tenant_integration_configurations.build(
          integration_provider: provider,
          credentials: @params[:credentials],
          enabled_features: @params[:enabled_features] || [],
          sync_frequency: @params[:sync_frequency] || "daily",
          sync_hour: @params[:sync_hour] || 2,
          sync_day_of_week: @params[:sync_day_of_week],
          sync_day_of_month: @params[:sync_day_of_month],
          sync_config: @params[:sync_config] || {},
          is_active: false # Inicia inactiva hasta que se valide
        )

        if config.save
          ServiceResult.success(
            data: config,
            message: "Configuración creada exitosamente"
          )
        else
          ServiceResult.failure(errors: config.errors.full_messages)
        end
      rescue StandardError => e
        Rails.logger.error("Error al crear configuración: #{e.message}")
        ServiceResult.failure(errors: [ "Error al crear la configuración" ])
      end
    end
  end
end

# app/services/integrations/tenant_configurations/deactivate_service.rb
module Integrations
  module TenantConfigurations
    class DeactivateService
      def initialize(config)
        @config = config
      end

      def call
        if @config.deactivate!
          ServiceResult.success(
            data: @config,
            message: "Configuración desactivada. Los datos históricos se mantienen."
          )
        else
          ServiceResult.failure(errors: @config.errors.full_messages)
        end
      rescue StandardError => e
        Rails.logger.error("Error al desactivar configuración: #{e.message}")
        ServiceResult.failure(errors: [ "Error al desactivar la configuración" ])
      end
    end
  end
end

# app/services/integrations/tenant_configurations/destroy_service.rb
module Integrations
  module TenantConfigurations
    class DestroyService
      def initialize(config)
        @config = config
      end

      def call
        # Validar que esté inactiva antes de eliminar
        if @config.is_active
          return ServiceResult.failure(
            errors: [ "Debe desactivar la configuración antes de eliminarla" ]
          )
        end

        if @config.destroy
          ServiceResult.success(message: "Configuración eliminada exitosamente")
        else
          ServiceResult.failure(errors: @config.errors.full_messages)
        end
      rescue StandardError => e
        Rails.logger.error("Error al eliminar configuración: #{e.message}")
        ServiceResult.failure(errors: [ "Error al eliminar la configuración" ])
      end
    end
  end
end

# app/services/integrations/tenant_configurations/test_connection_service.rb
module Integrations
  module TenantConfigurations
    class TestConnectionService
      def initialize(provider_id, credentials)
        @provider_id = provider_id
        @credentials = credentials
      end

      def call
        # PASO 1: Validar proveedor
        provider = validate_provider
        return provider unless provider.is_a?(IntegrationProvider)

        # PASO 2: Verificar que tenga conector implementado
        unless Factories::ConnectorFactory.provider_available?(provider.slug)
          return ServiceResult.failure(
            errors: [ "El proveedor no tiene conector implementado aún" ]
          )
        end

        # PASO 3: Crear configuración temporal (NO se guarda en BD)
        temp_config = build_temp_config(provider)

        # PASO 4: Intentar autenticar
        test_authentication(temp_config, provider)

      rescue StandardError => e
        Rails.logger.error("Error en test de conexión: #{e.message}")
        ServiceResult.failure(
          errors: [ "Error al probar conexión: #{e.message}" ]
        )
      end

      private

      def validate_provider
        provider = IntegrationProvider.find_by(id: @provider_id)

        unless provider
          return ServiceResult.failure(
            errors: [ "Proveedor no encontrado" ]
          )
        end

        unless provider.available?
          return ServiceResult.failure(
            errors: [ "El proveedor no está disponible" ]
          )
        end

        provider
      end

      def build_temp_config(provider)
        # Crear instancia SIN guardar en BD
        TenantIntegrationConfiguration.new(
          integration_provider: provider,
          credentials: @credentials,
          is_active: false # No está activa, es solo para test
        )
      end


      def test_authentication(temp_config, provider)
        Rails.logger.info("→ Probando conexión con #{provider.name}...")

        # Construir connector con config temporal
        connector = ConnectorFactory.build(provider.slug, temp_config)

        # Intentar autenticar
        auth_result = connector.authenticate

        if auth_result
          # Autenticación exitosa
          Rails.logger.info("✓ Conexión exitosa con #{provider.name}")

          ServiceResult.success(
            data: {
              success: true,
              provider_name: provider.name,
              provider_slug: provider.slug,
              message: "Conexión establecida exitosamente",
              tested_at: Time.current
            }
          )
        else
          # Autenticación falló
          ServiceResult.failure(
            errors: [ "No se pudo establecer conexión con #{provider.name}" ]
          )
        end

      rescue Integrations::Connectors::BaseConnector::AuthenticationError => e
        # Error de credenciales
        Rails.logger.error("✗ Test de conexión falló: #{e.message}")

        ServiceResult.failure(
          errors: [ "Credenciales inválidas: #{e.message}" ]
        )

      rescue Integrations::Connectors::BaseConnector::ApiError => e
        # Error de API
        Rails.logger.error("✗ Error de API: #{e.message}")

        ServiceResult.failure(
          errors: [ "Error de conexión: #{e.message}" ]
        )

      rescue StandardError => e
        # Otro error
        Rails.logger.error("✗ Error inesperado: #{e.message}")

        ServiceResult.failure(
          errors: [ "Error al probar conexión: #{e.message}" ]
        )
      end
    end
  end
end

# app/services/integrations/tenant_configurations/update_credentials_service.rb
module Integrations
  module TenantConfigurations
    class UpdateCredentialsService
      def initialize(config, new_credentials, test_connection: false)
        @config = config
        @new_credentials = new_credentials
        @test_connection = test_connection
        @was_active = config.is_active
      end

      def call
        # PASO 1: Validar estructura de credenciales
        validation = validate_credentials_structure
        return validation if validation.failure?

        # PASO 2: Si está activa, desactivar temporalmente
        @config.update!(is_active: false) if @was_active

        # PASO 3: Actualizar credenciales
        unless @config.update(credentials: @new_credentials)
          return ServiceResult.failure(
            errors: @config.errors.full_messages
          )
        end

        # PASO 4: Limpiar estado de última sync
        @config.update!(last_sync_status: nil, last_sync_error: nil)

        # PASO 5: Probar conexión si se solicita
        if @test_connection
          test_result = test_new_connection
          return test_result if test_result.failure?
        end

        # PASO 6: Re-activar si estaba activa
        @config.update!(is_active: true) if @was_active

        ServiceResult.success(
          data: @config,
          message: "Credenciales actualizadas exitosamente"
        )

      rescue StandardError => e
        Rails.logger.error("Error al actualizar credenciales: #{e.message}")
        ServiceResult.failure(
          errors: [ "Error al actualizar credenciales: #{e.message}" ]
        )
      end

      private

      def validate_credentials_structure
        schema = @config.integration_provider.integration_auth_schema
        return ServiceResult.failure(errors: [ "Proveedor sin schema de autenticación" ]) unless schema

        required_fields = schema.required_fields.map { |f| f["name"] }
        missing_fields = required_fields - @new_credentials.keys.map(&:to_s)

        if missing_fields.any?
          return ServiceResult.failure(
            errors: [ "Faltan campos requeridos: #{missing_fields.join(', ')}" ]
          )
        end

        ServiceResult.success
      end

      def test_new_connection
        result = TestConnectionService.new(
          @config.integration_provider.id,
          @new_credentials
        ).call

        unless result.success?
          return ServiceResult.failure(
            errors: [ "Test de conexión falló: #{result.errors.join(', ')}" ]
          )
        end

        ServiceResult.success
      end
    end
  end
end

# app/services/integrations/tenant_configurations/update_features_service.rb
module Integrations
  module TenantConfigurations
    class UpdateFeaturesService
      def initialize(config, enabled_features)
        @config = config
        @enabled_features = enabled_features
      end

      def call
        # PASO 1: Validar que las features existan
        validation = validate_features
        return validation if validation.failure?

        # PASO 2: Actualizar features
        if @config.update(enabled_features: @enabled_features)
          ServiceResult.success(
            data: @config,
            message: "Features actualizadas exitosamente"
          )
        else
          ServiceResult.failure(
            errors: @config.errors.full_messages
          )
        end

      rescue StandardError => e
        Rails.logger.error("Error al actualizar features: #{e.message}")
        ServiceResult.failure(
          errors: [ "Error al actualizar features: #{e.message}" ]
        )
      end

      private

      def validate_features
        unless @enabled_features.is_a?(Array)
          return ServiceResult.failure(
            errors: [ "enabled_features debe ser un array" ]
          )
        end

        available_features = @config.integration_provider.integration_features.active.pluck(:feature_key)
        invalid_features = @enabled_features - available_features

        if invalid_features.any?
          return ServiceResult.failure(
            errors: [ "Features no disponibles: #{invalid_features.join(', ')}" ],
            data: { available_features: available_features }
          )
        end

        ServiceResult.success
      end
    end
  end
end

# app/services/integrations/tenant_configurations/update_schedule_service.rb
module Integrations
  module TenantConfigurations
    class UpdateScheduleService
      def initialize(config, schedule_params)
        @config = config
        @schedule_params = schedule_params
      end

      def call
        # PASO 1: Validar parámetros de programación
        validation = validate_schedule_params
        return validation if validation.failure?

        # PASO 2: Actualizar programación
        if @config.update(@schedule_params)
          ServiceResult.success(
            data: @config,
            message: "Programación actualizada exitosamente"
          )
        else
          ServiceResult.failure(
            errors: @config.errors.full_messages
          )
        end

      rescue StandardError => e
        Rails.logger.error("Error al actualizar programación: #{e.message}")
        ServiceResult.failure(
          errors: [ "Error al actualizar programación: #{e.message}" ]
        )
      end

      private

      def validate_schedule_params
        # Validar frecuencia
        unless %w[daily weekly monthly].include?(@schedule_params[:sync_frequency])
          return ServiceResult.failure(
            errors: [ "Frecuencia no válida: #{@schedule_params[:sync_frequency]}" ]
          )
        end

        # Validar hora
        hour = @schedule_params[:sync_hour]
        unless hour.is_a?(Integer) && hour >= 0 && hour <= 23
          return ServiceResult.failure(
            errors: [ "Hora no válida: #{hour}" ]
          )
        end

        # Para POC, no validamos estrictamente day_of_week y day_of_month
        # En producción se validarían según la frecuencia

        ServiceResult.success
      end
    end
  end
end

# app/services/integrations/tenant_configurations/update_service.rb
module Integrations
  module TenantConfigurations
    class UpdateService
      def initialize(config, params)
        @config = config
        @params = params
      end

      def call
        # Si se actualizan credenciales, marcar para revalidación
        if @params.key?(:credentials) && @params[:credentials] != @config.credentials
          @params[:last_sync_status] = nil
          @params[:last_sync_error] = nil
        end

        if @config.update(@params)
          ServiceResult.success(
            data: @config,
            message: "Configuración actualizada exitosamente"
          )
        else
          ServiceResult.failure(errors: @config.errors.full_messages)
        end
      rescue StandardError => e
        Rails.logger.error("Error al actualizar configuración: #{e.message}")
        ServiceResult.failure(errors: [ "Error al actualizar la configuración" ])
      end
    end
  end
end

# app/services/integrations/vehicle_mappings/create_mapping_service.rb
module Integrations
  module VehicleMappings
    class CreateMappingService
      def initialize(config, vehicle, external_vehicle_id, external_vehicle_name = nil)
        @config = config
        @vehicle = vehicle
        @external_vehicle_id = external_vehicle_id
        @external_vehicle_name = external_vehicle_name
      end

      def call
        # Verificar si ya existe mapeo para este external_vehicle_id
        existing = @config.vehicle_provider_mappings.find_by(
          external_vehicle_id: @external_vehicle_id
        )

        if existing
          return ServiceResult.failure(
            errors: [ "El vehículo externo '#{@external_vehicle_id}' ya está mapeado" ]
          )
        end

        # Crear mapeo
        mapping = @config.vehicle_provider_mappings.build(
          vehicle: @vehicle,
          external_vehicle_id: @external_vehicle_id,
          external_vehicle_name: @external_vehicle_name,
          is_active: true,
          mapped_at: Time.current
        )

        if mapping.save
          ServiceResult.success(
            data: mapping,
            message: "Mapeo creado exitosamente"
          )
        else
          ServiceResult.failure(errors: mapping.errors.full_messages)
        end

      rescue StandardError => e
        Rails.logger.error("Error al crear mapeo: #{e.message}")
        ServiceResult.failure(errors: [ e.message ])
      end
    end
  end
end

# app/services/service_result.rb
class ServiceResult
  attr_reader :success, :data, :errors, :message

  def initialize(success:, data: nil, errors: [], message: nil)
    @success = success
    @data = data
    @errors = errors
    @message = message
  end

  def self.success(data: nil, message: nil)
    new(success: true, data: data, message: message)
  end

  def self.failure(errors: [], message: nil)
    new(success: false, errors: errors, message: message)
  end

  def success?
    @success
  end

  def failure?
    !@success
  end
end
