# app/models/integration_auth_schema.rb
class IntegrationAuthSchema < ApplicationRecord
  belongs_to :integration_provider

  validates :auth_fields, presence: true
  validates :integration_provider_id, uniqueness: {
    scope: :is_active,
    conditions: -> { where(is_active: true) },
    message: "ya tiene un schema de autenticación activo"
  }, if: :is_active?
  validate :validate_auth_fields_structure

  scope :active, -> { where(is_active: true) }

  def field_names
    return [] unless auth_fields.is_a?(Array)
    auth_fields.map { |field| field["name"] }.compact
  end

  def required_fields
    return [] unless auth_fields.is_a?(Array)
    auth_fields.select { |field| field["required"] == true }
  end

  private

  def validate_auth_fields_structure
    return if auth_fields.blank?

    unless auth_fields.is_a?(Array)
      errors.add(:auth_fields, "debe ser un array")
      return
    end

    auth_fields.each_with_index do |field, index|
      unless field.is_a?(Hash)
        errors.add(:auth_fields, "el elemento #{index} debe ser un objeto")
        next
      end

      # Validar campos requeridos
      required_keys = [ "name", "type", "label" ]
      missing_keys = required_keys - field.keys

      if missing_keys.any?
        errors.add(:auth_fields, "el campo #{index} requiere: #{missing_keys.join(', ')}")
      end

      # Validar tipos permitidos
      valid_types = [ "text", "password", "url", "select" ]
      if field["type"].present? && !valid_types.include?(field["type"])
        errors.add(:auth_fields, "tipo '#{field['type']}' no válido en campo #{index}")
      end
    end
  end
end

# app/models/integration_category.rb
class IntegrationCategory < ApplicationRecord
  has_many :integration_providers, dependent: :destroy

  validates :name, presence: true, length: { maximum: 100 }
  validates :slug, presence: true,
                   length: { maximum: 50 },
                   uniqueness: true,
                   format: { with: /\A[a-z0-9_]+\z/, message: "solo permite minúsculas, números y guiones bajos" }
  validates :icon, length: { maximum: 50 }, allow_blank: true
  validates :display_order, presence: true, numericality: { only_integer: true }

  scope :active, -> { where(is_active: true) }
  scope :ordered, -> { order(display_order: :asc, name: :asc) }
  scope :for_marketplace, -> { active.ordered }

  before_validation :generate_slug, if: -> { slug.blank? && name.present? }

  private

  def generate_slug
    self.slug = name.parameterize.underscore
  end
end

# app/models/integration_feature.rb
class IntegrationFeature < ApplicationRecord
  belongs_to :integration_provider

  validates :feature_key, presence: true,
                          length: { maximum: 50 },
                          format: { with: /\A[a-z0-9_]+\z/, message: "solo permite minúsculas, números y guiones bajos" },
                          uniqueness: { scope: :integration_provider_id }
  validates :feature_name, presence: true, length: { maximum: 100 }
  validates :display_order, presence: true, numericality: { only_integer: true }

  scope :active, -> { where(is_active: true) }
  scope :ordered, -> { order(display_order: :asc, feature_name: :asc) }

  def available?
    is_active
  end
end

# app/models/integration_provider.rb
class IntegrationProvider < ApplicationRecord
  belongs_to :integration_category
  has_one :integration_auth_schema, dependent: :destroy
  has_many :integration_features, dependent: :destroy
  has_many :tenant_integration_configurations, dependent: :restrict_with_error

  validates :name, presence: true, length: { maximum: 100 }
  validates :slug, presence: true,
                   length: { maximum: 50 },
                   uniqueness: true,
                   format: { with: /\A[a-z0-9_]+\z/, message: "solo permite minúsculas, números y guiones bajos" }
  validates :status, presence: true,
                     inclusion: { in: %w[active coming_soon deprecated beta] }
  validates :api_base_url, length: { maximum: 500 }, allow_blank: true
  validates :logo_url, length: { maximum: 500 }, allow_blank: true
  validates :website_url, length: { maximum: 500 }, allow_blank: true
  validates :display_order, presence: true, numericality: { only_integer: true }

  scope :active, -> { where(is_active: true) }
  scope :by_status, ->(status) { where(status: status) }
  scope :premium, -> { where(is_premium: true) }
  scope :free, -> { where(is_premium: false) }
  scope :ordered, -> { order(display_order: :asc, name: :asc) }
  scope :for_marketplace, -> { active.where(status: [ "active", "beta" ]).ordered }

  before_validation :generate_slug, if: -> { slug.blank? && name.present? }

  def available?
    is_active && status.in?([ "active", "beta" ])
  end

  def ready_for_production?
    is_active && status == "active"
  end

  def configured_by_tenant?(tenant)
    tenant_integration_configurations.exists?(tenant: tenant)
  end

  def active_configurations_count
    tenant_integration_configurations.active.count
  end

  private

  def generate_slug
    self.slug = name.parameterize.underscore
  end
end

# app/models/integration_raw_data.rb
class IntegrationRawData < ApplicationRecord
  belongs_to :integration_sync_execution
  belongs_to :tenant_integration_configuration
  belongs_to :normalized_record, polymorphic: true, optional: true

  delegate :tenant, :integration_provider, to: :tenant_integration_configuration

  validates :provider_slug, presence: true
  validates :feature_key, presence: true
  validates :external_id, presence: true
  validates :raw_data, presence: true
  validates :processing_status, presence: true,
                                inclusion: { in: %w[pending normalized failed duplicate skipped] }

  scope :pending, -> { where(processing_status: "pending") }
  scope :normalized, -> { where(processing_status: "normalized") }
  scope :failed, -> { where(processing_status: "failed") }
  scope :duplicate, -> { where(processing_status: "duplicate") }
  scope :skipped, -> { where(processing_status: "skipped") }
  scope :normalizable, -> { where(processing_status: %w[pending failed]) }
  scope :by_feature, ->(feature) { where(feature_key: feature) }
  scope :by_provider, ->(provider) { where(provider_slug: provider) }
  scope :by_execution, ->(execution_id) { where(integration_sync_execution_id: execution_id) }
  scope :recent, -> { order(created_at: :desc) }
  scope :with_errors, -> { failed.order(created_at: :desc) }
  scope :not_deleted, -> { where(deleted_at: nil) }
  scope :by_status, ->(status) { where(processing_status: status) }
  scope :retriable, -> {
    where(processing_status: "failed").select { |r| r.retriable_error? }
  }
  scope :with_error_type, ->(error_type) {
    where(processing_status: "failed").select do |r|
      detect_error_type(r.normalization_error) == error_type
    end
  }

  def pending?
    processing_status == "pending"
  end

  def normalized?
    processing_status == "normalized"
  end

  def failed?
    processing_status == "failed"
  end

  def duplicate?
    processing_status == "duplicate"
  end

  def skipped?
    processing_status == "skipped"
  end

  def can_be_retried?
    failed? && retriable_error?
  end

  def mark_as_skipped!(reason)
    update!(
      processing_status: "skipped",
      normalization_error: reason,
      metadata: (self.metadata || {}).merge(  # ← self.metadata
        skip_reason: reason,
        skipped_at: Time.current.iso8601
      )
    )
  end

  def reset_for_reprocessing!
    update!(
      processing_status: "pending",
      normalized_record_type: nil,
      normalized_record_id: nil,
      normalization_error: nil,
      normalized_at: nil
    )
  end

  def permanent_error?
    !retriable_error?
  end

  def error_type
    return nil unless failed?
    return "unknown_error" if normalization_error.blank?

    case normalization_error
    when /vehicle mapping not found/i
      "vehicle_mapping_missing"
    when /vehicle not found/i
      "vehicle_not_found"
    when /invalid data format/i
      "invalid_data_format"
    when /missing required field/i
      "missing_required_field"
    else
      "unknown_error"
    end
  end

  def raw_field(key)
    raw_data&.dig(key.to_s)
  end

  def has_raw_field?(key)
    raw_data&.key?(key.to_s)
  end

  def description
    "#{provider_slug}/#{feature_key} - #{external_id[0..10]}..."
  end

  # Estadísticas por estado
  def self.count_by_status
    group(:processing_status).count
  end

  def self.error_summary
    failed.group(:normalization_error).count
      .sort_by { |_, count| -count }
      .first(10)
  end

  # Detectar si el error es recuperable
  def retriable_error?
    return false unless normalization_error.present?

    retriable_patterns = [
      /vehicle mapping not found/i,
      /vehicle not found/i,
      /timeout/i,
      /connection/i,
      /temporary/i
    ]

    retriable_patterns.any? { |pattern| normalization_error.match?(pattern) }
  end

  # Verificar si puede ser normalizado
  def can_be_normalized?
    [ "pending", "failed" ].include?(processing_status)
  end

  # Verificar si puede ser omitido
  def can_be_skipped?
    [ "pending", "failed" ].include?(processing_status)
  end

  # Verificar si puede ser reseteado
  def can_be_reset?
    [ "failed", "skipped", "duplicate" ].include?(processing_status)
  end

  # Calcular duración de procesamiento
  def processing_duration_ms
    return nil unless normalized_at && created_at
    ((normalized_at - created_at) * 1000).round
  end

  # Obtener registro normalizado (polimórfico)
  def normalized_record
    return nil unless normalized_record_type && normalized_record_id
    normalized_record_type.constantize.find_by(id: normalized_record_id)
  rescue NameError
    nil
  end

  # Marcar como fallido con información adicional
  def mark_as_failed!(error_msg, error_type: nil)
    update!(
      processing_status: "failed",
      normalization_error: error_msg,
      normalized_at: Time.current,
      metadata: (self.metadata || {}).merge(
        error_type: error_type || self.class.detect_error_type(error_msg),
        failed_at: Time.current.iso8601,
        retry_count: retry_count || 0
      )
    )
  end

  # Marcar como normalizado
  def mark_as_normalized!(normalized_record)
    update!(
      processing_status: "normalized",
      normalized_record_type: normalized_record.class.name,
      normalized_record_id: normalized_record.id,
      normalized_at: Time.current,
      normalization_error: nil,
      metadata: (self.metadata || {}).merge(
        normalized_at: Time.current.iso8601,
        processing_duration_ms: processing_duration_ms
      )
    )
  end

  # Marcar como duplicado
  def mark_as_duplicate!(original_id = nil)
    update!(
      processing_status: "duplicate",
      normalized_at: Time.current,
      metadata: (self.metadata || {}).merge(
        duplicate_of: original_id,
        duplicate_detected_at: Time.current.iso8601
      )
    )
  end

  # Encontrar el registro original (si es duplicado)
  def find_original_record
    return nil unless processing_status == "duplicate"

    duplicate_of_id = metadata&.dig("duplicate_of")
    return IntegrationRawData.find_by(id: duplicate_of_id) if duplicate_of_id

    # Si no está en metadata, buscar por external_id
    IntegrationRawData
      .where(
        tenant_integration_configuration_id: tenant_integration_configuration_id,
        external_id: external_id,
        processing_status: "normalized"
      )
      .where.not(id: id)
      .first
  end

  # Encontrar registros similares (con el mismo error)
  def find_similar_failed_records(limit: 5)
    return [] unless processing_status == "failed"

    key_error = self.class.extract_key_error_part(normalization_error)

    IntegrationRawData
      .where(tenant_integration_configuration_id: tenant_integration_configuration_id)
      .where(processing_status: "failed")
      .where.not(id: id)
      .where("normalization_error LIKE ?", "%#{key_error}%")
      .limit(limit)
  end

  class << self
    # Detectar tipo de error desde mensaje
    def detect_error_type(error_message)
      return "unknown" unless error_message.present?

      error_msg = error_message.downcase

      case error_msg
      when /vehicle mapping not found|vehicle not found/
        "vehicle_not_found"
      when /authentication|credentials|unauthorized/
        "authentication_error"
      when /device.*reassign|external.*changed/
        "device_reassignment"
      when /invalid.*format/
        "invalid_data_format"
      when /missing.*field|required field/
        "missing_required_field"
      when /duplicate/
        "duplicate_detection"
      when /timeout|timed out/
        "timeout_error"
      when /connection/
        "connection_error"
      else
        "normalization_error"
      end
    end

    # Extraer parte clave del error
    def extract_key_error_part(error_message)
      return "" unless error_message

      # Si contiene "vehicle mapping", extraer el external_id
      if error_message.include?("mapping not found")
        match = error_message.match(/external_id[:\s]+([a-zA-Z0-9_-]+)/)
        return "external_id: #{match[1]}" if match
      end

      # Si es otro tipo de error, tomar las primeras palabras clave
      error_message.split(":").first&.strip || error_message[0..50]
    end

    # Crear o manejar duplicado (mejorado)
    def create_or_handle_duplicate(attributes)
      existing = find_by(
        tenant_integration_configuration_id: attributes[:tenant_integration_configuration_id],
        external_id: attributes[:external_id],
        feature_key: attributes[:feature_key]
      )

      if existing
        # Si existe y tiene datos diferentes, podría ser actualización
        if existing.raw_data != attributes[:raw_data]
          # Hay cambios → reprocesar si ya fue normalizado
          if existing.processing_status == "normalized"
            existing.update!(
              raw_data: attributes[:raw_data],
              processing_status: "pending",
              normalized_record_type: nil,
              normalized_record_id: nil,
              metadata: (existing.metadata || {}).merge(
                updated_from_sync: Time.current.iso8601,
                previous_normalized_at: existing.normalized_at
              )
            )
            existing
          else
            # Ya estaba pending o failed, solo actualizar datos
            existing.update!(raw_data: attributes[:raw_data])
            existing
          end
        else
          # Verdadero duplicado sin cambios
          existing.mark_as_duplicate! unless existing.duplicate?
          existing
        end
      else
        # No existe, crear nuevo
        create!(attributes)
      end
    end

    # Estadísticas rápidas
    def quick_stats(scope = all)
      {
        total: scope.count,
        pending: scope.where(processing_status: "pending").count,
        normalized: scope.where(processing_status: "normalized").count,
        failed: scope.where(processing_status: "failed").count,
        duplicate: scope.where(processing_status: "duplicate").count,
        skipped: scope.where(processing_status: "skipped").count
      }
    end
  end
end

# app/models/integration_sync_execution.rb
class IntegrationSyncExecution < ApplicationRecord
  belongs_to :tenant_integration_configuration
  has_many :integration_raw_data,
           class_name: "IntegrationRawData",
           dependent: :destroy

  delegate :tenant, :integration_provider, to: :tenant_integration_configuration
  delegate :name, to: :integration_provider, prefix: true

  validates :feature_key, presence: true,
                          inclusion: {
                            in: %w[fuel battery trips real_time_location odometer diagnostics],
                            message: "%{value} no es una feature válida"
                          }
  validates :trigger_type, presence: true,
                           inclusion: { in: %w[manual scheduled test] }
  validates :status, presence: true,
                     inclusion: { in: %w[running completed failed] }
  validates :started_at, presence: true
  validates :finished_at, presence: true, if: -> { completed? || failed? }
  validates :duration_seconds, presence: true, if: -> { finished_at.present? }

  scope :running, -> { where(status: "running") }
  scope :completed, -> { where(status: "completed") }
  scope :failed, -> { where(status: "failed") }
  scope :manual, -> { where(trigger_type: "manual") }
  scope :scheduled, -> { where(trigger_type: "scheduled") }
  scope :recent, -> { order(started_at: :desc) }
  scope :by_feature, ->(feature) { where(feature_key: feature) }
  scope :by_config, ->(config_id) { where(tenant_integration_configuration_id: config_id) }
  scope :today, -> { where("started_at >= ?", Time.current.beginning_of_day) }
  scope :this_week, -> { where("started_at >= ?", Time.current.beginning_of_week) }

  before_create :set_started_at

  def running?
    status == "running"
  end

  def completed?
    status == "completed"
  end

  def failed?
    status == "failed"
  end

  def finished?
    completed? || failed?
  end

  # Marcar como completada
  def mark_as_completed!
    update!(
      status: "completed",
      finished_at: Time.current,
      duration_seconds: calculate_duration
    )
  end

  # Marcar como fallida
  def mark_as_failed!(error_msg)
    update!(
      status: "failed",
      finished_at: Time.current,
      duration_seconds: calculate_duration,
      error_message: error_msg
    )
  end

  # Actualizar estadísticas
  def update_statistics!(stats)
    update!(
      records_fetched: stats[:fetched] || 0,
      records_processed: stats[:processed] || 0,
      records_failed: stats[:failed] || 0,
      records_skipped: stats[:skipped] || 0
    )
  end

  # Calcular tasa de éxito
  def success_rate
    return 0 if records_fetched.zero?
    ((records_processed.to_f / records_fetched) * 100).round(2)
  end

  # Verificar si hubo errores
  def has_errors?
    records_failed > 0
  end

  # Verificar si hubo duplicados
  def has_duplicates?
    records_skipped > 0
  end

  # Resumen de la ejecución
  def summary
    {
      id: id,
      feature: feature_key,
      status: status,
      duration: duration_seconds,
      success_rate: "#{success_rate}%",
      stats: {
        fetched: records_fetched,
        processed: records_processed,
        failed: records_failed,
        skipped: records_skipped
      }
    }
  end

  # Descripción legible
  def description
    provider = integration_provider_name
    feature = I18n.t("features.#{feature_key}", default: feature_key.humanize)
    trigger = I18n.t("triggers.#{trigger_type}", default: trigger_type.humanize)

    "#{provider} - #{feature} (#{trigger})"
  end

  # Obtener raw_data con errores
  def failed_raw_data
    integration_raw_data.where(processing_status: "failed")
  end

  # Obtener raw_data pendientes
  def pending_raw_data
    integration_raw_data.where(processing_status: "pending")
  end

  private

  def set_started_at
    self.started_at ||= Time.current
  end

  def calculate_duration
    return nil unless started_at && finished_at
    (finished_at - started_at).to_i
  end
end

# app/models/tenant_integration_configuration.rb
class TenantIntegrationConfiguration < ApplicationRecord
  encrypts :credentials, deterministic: false

  belongs_to :tenant
  belongs_to :integration_provider
  has_many :vehicle_provider_mappings, dependent: :destroy
  has_many :vehicles, through: :vehicle_provider_mappings
  has_many :integration_sync_executions, dependent: :destroy
  has_many :integration_raw_data, class_name: "IntegrationRawData", dependent: :destroy

  delegate :name, :slug, :logo_url, :api_base_url, to: :integration_provider, prefix: true
  delegate :integration_features, :integration_auth_schema, to: :integration_provider

  validates :tenant_id, uniqueness: {
    scope: :integration_provider_id,
    message: "ya tiene una configuración para este proveedor"
  }
  validates :enabled_features, presence: true
  validate :validate_enabled_features_structure
  validate :validate_credentials_structure, if: -> { credentials.present? }
  validates :sync_frequency, presence: true, inclusion: { in: %w[daily weekly monthly] }
  validates :sync_hour, presence: true, numericality: {
    only_integer: true,
    greater_than_or_equal_to: 0,
    less_than_or_equal_to: 23
  }

  scope :active, -> { where(is_active: true) }
  scope :inactive, -> { where(is_active: false) }
  scope :by_provider, ->(provider_slug) {
    joins(:integration_provider).where(integration_providers: { slug: provider_slug })
  }
  scope :with_errors, -> { where(last_sync_status: "error") }
  scope :successful, -> { where(last_sync_status: "success") }

  before_save :set_activated_at, if: -> { is_active_changed? && is_active? }

  def activate!
    return false unless can_be_activated?
    update!(is_active: true)
  end

  def deactivate!
    update!(is_active: false)
  end

  def active?
    is_active
  end

  def can_be_activated?
    # Verificaciones para poder activar
    return false unless credentials.present?
    return false unless enabled_features.any?
    true
  end

  def has_error?
    last_sync_status == "error"
  end

  def last_sync_successful?
    last_sync_status == "success"
  end

  def feature_enabled?(feature_key)
    enabled_features.include?(feature_key.to_s)
  end

  def available_features
    integration_provider.integration_features.active.where(feature_key: enabled_features)
  end

  # Descripción de programación para mostrar en UI
  def sync_schedule_description
    case sync_frequency
    when "daily"
      "Todos los días a las #{format_hour(sync_hour)}"
    when "weekly"
      day_name = %w[Domingo Lunes Martes Miércoles Jueves Viernes Sábado][sync_day_of_week || 0]
      "Todos los #{day_name} a las #{format_hour(sync_hour)}"
    when "monthly"
      day_desc = sync_day_of_month == "start" ? "el primer día del mes" : "el último día del mes"
      "#{day_desc.capitalize} a las #{format_hour(sync_hour)}"
    end
  end

  # Marcar última sync como exitosa
  def mark_sync_success!(timestamp = Time.current)
    update!(
      last_sync_at: timestamp,
      last_sync_status: "success",
      last_sync_error: nil
    )
  end

  # Marcar última sync con error
  def mark_sync_error!(error_message)
    update!(
      last_sync_at: Time.current,
      last_sync_status: "error",
      last_sync_error: error_message
    )
  end

  # Vehículos mapeados activos
  def mapped_vehicles
    vehicles.joins(:vehicle_provider_mappings)
            .where(vehicle_provider_mappings: { is_active: true })
            .distinct
  end

  # Verificar si un vehículo está mapeado
  def vehicle_mapped?(vehicle)
    vehicle_provider_mappings.active.exists?(vehicle: vehicle)
  end

  # Obtener mapeo de un vehículo
  def mapping_for(vehicle)
    vehicle_provider_mappings.active.find_by(vehicle: vehicle)
  end

  # Última ejecución de sync
  def last_sync_execution
    integration_sync_executions.recent.first
  end

  # Ejecuciones por feature
  def sync_executions_for(feature_key)
    integration_sync_executions.by_feature(feature_key).recent
  end

  # Estadísticas
  def sync_statistics
    {
      total_executions: integration_sync_executions.count,
      completed: integration_sync_executions.completed.count,
      failed: integration_sync_executions.failed.count,
      total_raw_records: integration_raw_data.count,
      pending_records: integration_raw_data.pending.count,
      failed_records: integration_raw_data.failed.count
    }
  end

  private

  def set_activated_at
    self.activated_at = Time.current
  end

  def format_hour(hour)
    Time.current.change(hour: hour).strftime("%H:%M")
  end

  def validate_credentials_structure
    return unless integration_provider&.integration_auth_schema

    schema = integration_provider.integration_auth_schema
    required_fields = schema.required_fields.map { |f| f["name"] }

    # Obtener el valor de credentials
    creds = credentials

    # Si credentials es nil, salir
    return if creds.nil?

    # Verificar que sea un Hash
    unless creds.is_a?(Hash)
      errors.add(:credentials, "debe ser un objeto JSON válido (recibido: #{creds.class})")
      return
    end

    # Validar campos requeridos
    missing_fields = required_fields - creds.keys.map(&:to_s)

    if missing_fields.any?
      errors.add(:credentials, "faltan campos requeridos: #{missing_fields.join(', ')}")
    end
  end

  def validate_enabled_features_structure
    unless enabled_features.is_a?(Array)
      errors.add(:enabled_features, "debe ser un array")
      return
    end

    # Validar que las features existan y estén activas
    available_feature_keys = integration_provider.integration_features.active.pluck(:feature_key)
    invalid_features = enabled_features - available_feature_keys

    if invalid_features.any?
      errors.add(:enabled_features, "contiene features no disponibles: #{invalid_features.join(', ')}")
    end
  end
end

# app/models/tenant.rb
class Tenant < ApplicationRecord
  has_many :tenant_integration_configurations, dependent: :destroy
  has_many :integration_providers, through: :tenant_integration_configurations
  has_many :vehicles, dependent: :destroy
  has_many :vehicle_refuelings, through: :vehicles
  has_many :vehicle_electric_charges, through: :vehicles

  validates :name, presence: true, length: { maximum: 255 }
  validates :slug, presence: true,
                   length: { maximum: 100 },
                   uniqueness: true,
                   format: { with: /\A[a-z0-9\-_]+\z/, message: "solo permite minúsculas, números, guiones y guiones bajos" }
  validates :status, presence: true,
                     inclusion: { in: %w[active suspended trial] }
  validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }, allow_blank: true

  scope :active, -> { where(status: "active") }
  scope :suspended, -> { where(status: "suspended") }
  scope :trial, -> { where(status: "trial") }
  scope :recent, -> { order(created_at: :desc) }
  scope :by_name, -> { order(:name) }
  scope :with_integrations, -> { joins(:tenant_integration_configurations).distinct }
  scope :without_activity, ->(days = 30) {
    left_joins(:tenant_integration_configurations)
      .where("tenant_integration_configurations.last_sync_at < ? OR tenant_integration_configurations.last_sync_at IS NULL",
             days.days.ago)
      .distinct
  }

  before_validation :generate_slug, if: -> { slug.blank? && name.present? }
  before_validation :normalize_email

  def active?
    status == "active"
  end

  def suspended?
    status == "suspended"
  end

  def trial?
    status == "trial"
  end

  def active_integrations
    tenant_integration_configurations.active
  end

  def has_integration?(provider_slug)
    integration_providers.exists?(slug: provider_slug)
  end

  def integration_for(provider_slug)
    tenant_integration_configurations
      .joins(:integration_provider)
      .find_by(integration_providers: { slug: provider_slug })
  end

  def active_vehicles
    vehicles.active
  end

  def vehicles_with_telemetry
    vehicles.joins(:vehicle_provider_mappings)
            .where(vehicle_provider_mappings: { is_active: true })
            .distinct
  end

  # Verificación de datos asociados
  def has_associated_data?
    vehicles.any? ||
    tenant_integration_configurations.any? ||
    vehicle_refuelings.any? ||
    vehicle_electric_charges.any?
  end

  def associated_data_summary
    {
      vehicles: vehicles.count,
      integrations: tenant_integration_configurations.count,
      refuelings: VehicleRefueling.by_tenant(id).count,
      charges: VehicleElectricCharge.by_tenant(id).count,
      total_records: vehicles.count +
                    tenant_integration_configurations.count +
                    VehicleRefueling.by_tenant(id).count +
                    VehicleElectricCharge.by_tenant(id).count
    }
  end

  def last_activity_date
    [
      tenant_integration_configurations.maximum(:last_sync_at),
      vehicles.maximum(:updated_at),
      VehicleRefueling.by_tenant(id).maximum(:refueling_date),
      VehicleElectricCharge.by_tenant(id).maximum(:charge_start_time)
    ].compact.max
  end

  def days_since_last_activity
    return nil unless last_activity_date
    ((Time.current - last_activity_date) / 1.day).to_i
  end

  def inactive_days?(threshold = 30)
    days = days_since_last_activity
    days.present? && days > threshold
  end

  def statistics(from_date = nil, to_date = nil)
    from_date ||= 30.days.ago
    to_date ||= Time.current

    {
      vehicles: {
        total: vehicles.count,
        active: vehicles.active.count,
        with_telemetry: vehicles_with_telemetry.count
      },
      integrations: {
        total: tenant_integration_configurations.count,
        active: active_integrations.count,
        with_errors: tenant_integration_configurations.with_errors.count
      },
      refuelings: {
        total: VehicleRefueling.by_tenant(id)
          .between_dates(from_date, to_date).count,
        total_liters: VehicleRefueling.by_tenant(id)
          .between_dates(from_date, to_date)
          .sum(:volume_liters).to_f.round(2),
        total_cost: VehicleRefueling.by_tenant(id)
          .between_dates(from_date, to_date)
          .sum(:cost).to_f.round(2)
      },
      charges: {
        total: VehicleElectricCharge.by_tenant(id)
          .between_dates(from_date, to_date).count,
        total_kwh: VehicleElectricCharge.by_tenant(id)
          .between_dates(from_date, to_date)
          .sum(:energy_consumed_kwh).to_f.round(2)
      }
    }
  end

  # Operaciones de estado
  def activate!
    update!(status: "active")
  end

  def suspend!
    transaction do
      update!(status: "suspended")
      # Desactivar todas las integraciones
      tenant_integration_configurations.active.update_all(is_active: false)
    end
  end

  def move_to_trial!
    update!(status: "trial")
  end

  # Descripción
  def display_name
    "#{name} (#{status.humanize})"
  end

  private

  def generate_slug
    base_slug = name.parameterize
    self.slug = base_slug
    counter = 1

    while Tenant.exists?(slug: self.slug)
      self.slug = "#{base_slug}-#{counter}"
      counter += 1
    end
  end

  def normalize_email
    self.email = email&.strip&.downcase
  end
end

# app/models/vehicle_electric_charge.rb
class VehicleElectricCharge < ApplicationRecord
  belongs_to :tenant
  belongs_to :vehicle
  belongs_to :integration_raw_data,
             class_name: "IntegrationRawData",
             optional: true

  has_one :raw_data_source,
          as: :normalized_record,
          class_name: "IntegrationRawData"

  validates :charge_start_time, presence: true
  validates :charge_type, inclusion: { in: %w[AC DC], allow_blank: true }
  validates :start_soc_percent, numericality: {
    greater_than_or_equal_to: 0,
    less_than_or_equal_to: 100
  }, allow_nil: true
  validates :end_soc_percent, numericality: {
    greater_than_or_equal_to: 0,
    less_than_or_equal_to: 100
  }, allow_nil: true
  validates :energy_consumed_kwh, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true
  validates :peak_power_kw, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true
  validates :duration_minutes, numericality: { greater_than: 0 }, allow_nil: true
  validates :location_lat, numericality: {
    greater_than_or_equal_to: -90,
    less_than_or_equal_to: 90
  }, allow_nil: true
  validates :location_lng, numericality: {
    greater_than_or_equal_to: -180,
    less_than_or_equal_to: 180
  }, allow_nil: true
  validates :integration_raw_data_id, uniqueness: true, allow_nil: true

  scope :by_tenant, ->(tenant_id) { where(tenant_id: tenant_id) }
  scope :by_vehicle, ->(vehicle_id) { where(vehicle_id: vehicle_id) }
  scope :between_dates, ->(from, to) { where(charge_start_time: from..to) }
  scope :recent, -> { order(charge_start_time: :desc) }
  scope :ac_charges, -> { where(charge_type: "AC") }
  scope :dc_charges, -> { where(charge_type: "DC") }
  scope :estimated, -> { where(is_estimated: true) }
  scope :measured, -> { where(is_estimated: false) }
  scope :complete_charges, -> { where("end_soc_percent >= ?", 95) }
  scope :this_month, -> { where("charge_start_time >= ?", Time.current.beginning_of_month) }
  scope :this_year, -> { where("charge_start_time >= ?", Time.current.beginning_of_year) }

  def soc_gained
    return nil unless start_soc_percent && end_soc_percent
    (end_soc_percent - start_soc_percent).round(2)
  end

  def duration_hours
    return nil unless duration_minutes
    (duration_minutes / 60.0).round(2)
  end

  def average_power_kw
    return nil unless energy_consumed_kwh && duration_hours && duration_hours > 0
    (energy_consumed_kwh / duration_hours).round(2)
  end

  def has_location?
    location_lat.present? && location_lng.present?
  end

  def from_integration?
    integration_raw_data_id.present?
  end

  def manual?
    !from_integration?
  end

  def is_fast_charge?
    charge_type == "DC"
  end

  def is_slow_charge?
    charge_type == "AC"
  end

  def is_complete_charge?
    end_soc_percent && end_soc_percent >= 95
  end

  # Coordenadas como array [lat, lng]
  def coordinates
    return nil unless has_location?
    [ location_lat, location_lng ]
  end

  def description
    "#{energy_consumed_kwh}kWh (#{charge_type}) el #{charge_start_time.strftime('%d/%m/%Y')}"
  end

  def self.total_energy
    sum(:energy_consumed_kwh).to_f.round(2)
  end

  def self.average_energy
    average(:energy_consumed_kwh).to_f.round(2)
  end

  def self.total_duration_hours
    (sum(:duration_minutes).to_f / 60).round(2)
  end

  def self.count_by_charge_type
    group(:charge_type).count
  end

  def self.monthly_summary(year = Time.current.year)
    where("EXTRACT(YEAR FROM charge_start_time) = ?", year)
      .group("EXTRACT(MONTH FROM charge_start_time)")
      .select(
        "EXTRACT(MONTH FROM charge_start_time) as month",
        "COUNT(*) as count",
        "SUM(energy_consumed_kwh) as total_kwh",
        "AVG(duration_minutes) as avg_duration_minutes"
      )
  end
end

# app/models/vehicle_provider_mapping.rb
class VehicleProviderMapping < ApplicationRecord
  belongs_to :vehicle
  belongs_to :tenant_integration_configuration

  delegate :tenant, :integration_provider, to: :tenant_integration_configuration
  delegate :name, to: :vehicle, prefix: true
  delegate :license_plate, to: :vehicle, prefix: true

  validates :external_vehicle_id, presence: true, length: { maximum: 100 }
  validates :vehicle_id, uniqueness: {
    scope: [ :tenant_integration_configuration_id, :is_active ],
    conditions: -> { where(is_active: true) },
    message: "ya tiene un mapeo activo para esta configuración"
  }, if: :is_active?
  validates :external_vehicle_id, uniqueness: {
    scope: :tenant_integration_configuration_id,
    message: "ya está mapeado a otro vehículo en esta configuración"
  }

  scope :active, -> { where(is_active: true) }
  scope :inactive, -> { where(is_active: false) }
  scope :by_config, ->(config_id) { where(tenant_integration_configuration_id: config_id) }
  scope :by_vehicle, ->(vehicle_id) { where(vehicle_id: vehicle_id) }
  scope :by_provider, ->(provider_slug) {
    joins(tenant_integration_configuration: :integration_provider)
      .where(integration_providers: { slug: provider_slug })
  }
  scope :by_external_id, ->(external_id) { where(external_vehicle_id: external_id) }
  scope :recent_sync, -> { order(last_sync_at: :desc) }

  before_create :set_mapped_at
  after_save :update_vehicle_telemetry_flag, if: :saved_change_to_is_active?

  def activate!
    self.class.where(
      vehicle_id: vehicle_id,
      tenant_integration_configuration_id: tenant_integration_configuration_id
    ).where.not(id: id).update_all(is_active: false)

    update!(is_active: true, mapped_at: Time.current)
  end

  def deactivate!
    update!(is_active: false)
  end

  def provider_name
    integration_provider.name
  end

  def provider_slug
    integration_provider.slug
  end

  def update_last_sync!
    update!(last_sync_at: Time.current)
  end

  def description
    "#{vehicle_name} (#{vehicle_license_plate}) ↔ #{provider_name} [#{external_vehicle_id}]"
  end

  private

  def set_mapped_at
    self.mapped_at ||= Time.current
  end
end

# app/models/vehicle_refueling.rb
class VehicleRefueling < ApplicationRecord
  belongs_to :tenant
  belongs_to :vehicle
  belongs_to :integration_raw_data,
             class_name: "IntegrationRawData",
             optional: true

  has_one :raw_data_source,
          as: :normalized_record,
          class_name: "IntegrationRawData"

  validates :refueling_date, presence: true
  validates :volume_liters, presence: true,
                            numericality: { greater_than: 0 }
  validates :cost, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true
  validates :currency, length: { is: 3 }, allow_blank: true
  validates :location_lat, numericality: {
    greater_than_or_equal_to: -90,
    less_than_or_equal_to: 90
  }, allow_nil: true
  validates :location_lng, numericality: {
    greater_than_or_equal_to: -180,
    less_than_or_equal_to: 180
  }, allow_nil: true
  validates :odometer_km, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true
  validates :integration_raw_data_id, uniqueness: true, allow_nil: true

  scope :by_tenant, ->(tenant_id) { where(tenant_id: tenant_id) }
  scope :by_vehicle, ->(vehicle_id) { where(vehicle_id: vehicle_id) }
  scope :between_dates, ->(from, to) { where(refueling_date: from..to) }
  scope :recent, -> { order(refueling_date: :desc) }
  scope :estimated, -> { where(is_estimated: true) }
  scope :measured, -> { where(is_estimated: false) }
  scope :with_cost, -> { where.not(cost: nil) }
  scope :by_fuel_type, ->(type) { where(fuel_type: type) }
  scope :this_month, -> { where("refueling_date >= ?", Time.current.beginning_of_month) }
  scope :this_year, -> { where("refueling_date >= ?", Time.current.beginning_of_year) }

  def cost_per_liter
    return nil unless cost && volume_liters && volume_liters > 0
    (cost / volume_liters).round(2)
  end

  def has_location?
    location_lat.present? && location_lng.present?
  end

  def has_cost?
    cost.present? && cost > 0
  end

  def from_integration?
    integration_raw_data_id.present?
  end

  def manual?
    !from_integration?
  end

   def coordinates
    return nil unless has_location?
    [ location_lat, location_lng ]
  end

  def description
    "#{volume_liters}L el #{refueling_date.strftime('%d/%m/%Y')}"
  end

  def self.total_volume
    sum(:volume_liters).round(2)
  end

  def self.total_cost
    sum(:cost).round(2)
  end

  def self.average_volume
    average(:volume_liters).to_f.round(2)
  end

  def self.count_by_fuel_type
    group(:fuel_type).count
  end

  def self.monthly_summary(year = Time.current.year)
    where("EXTRACT(YEAR FROM refueling_date) = ?", year)
      .group("EXTRACT(MONTH FROM refueling_date)")
      .select(
        "EXTRACT(MONTH FROM refueling_date) as month",
        "COUNT(*) as count",
        "SUM(volume_liters) as total_liters",
        "SUM(cost) as total_cost"
      )
  end
end

# app/models/vehicle.rb
class Vehicle < ApplicationRecord
  belongs_to :tenant

  has_many :vehicle_provider_mappings, dependent: :destroy
  has_many :tenant_integration_configurations, through: :vehicle_provider_mappings

  has_many :vehicle_refuelings, dependent: :destroy
  has_many :vehicle_electric_charges, dependent: :destroy

  validates :name, presence: true, length: { maximum: 255 }
  validates :license_plate, presence: true,
                            length: { maximum: 20 },
                            uniqueness: { scope: :tenant_id, case_sensitive: false }

  validates :vin, length: { is: 17 }, allow_blank: true,
                  uniqueness: true,
                  format: { with: /\A[A-HJ-NPR-Z0-9]{17}\z/, message: "formato VIN inválido" }
  validates :status, presence: true,
                     inclusion: { in: %w[active maintenance inactive sold] }
  validates :fuel_type, inclusion: {
    in: %w[diesel gasoline electric hybrid lpg cng hydrogen],
    message: "%{value} no es un tipo de combustible válido"
  }, allow_blank: true
  validates :vehicle_type, inclusion: {
    in: %w[car van truck motorcycle bus],
    message: "%{value} no es un tipo de vehículo válido"
  }, allow_blank: true
  validates :year, numericality: {
    only_integer: true,
    greater_than_or_equal_to: 1900,
    less_than_or_equal_to: -> { Date.current.year + 1 }
  }, allow_nil: true
  validates :tank_capacity_liters, numericality: { greater_than: 0 }, allow_nil: true
  validates :battery_capacity_kwh, numericality: { greater_than: 0 }, allow_nil: true
  validates :initial_odometer_km, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true
  validates :current_odometer_km, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true

  scope :active, -> { where(status: "active") }
  scope :inactive, -> { where(status: "inactive") }
  scope :in_maintenance, -> { where(status: "maintenance") }
  scope :electric, -> { where(is_electric: true) }
  scope :combustion, -> { where(is_electric: false) }
  scope :by_fuel_type, ->(type) { where(fuel_type: type) }
  scope :by_vehicle_type, ->(type) { where(vehicle_type: type) }
  scope :by_brand, ->(brand) { where(brand: brand) }
  scope :recent, -> { order(created_at: :desc) }
  scope :by_name, -> { order(:name) }

  before_validation :normalize_license_plate
  before_validation :set_is_electric_flag
  before_save :normalize_vin

  def active?
    status == "active"
  end

  def in_maintenance?
    status == "maintenance"
  end

  def inactive?
    status == "inactive"
  end

  def sold?
    status == "sold"
  end

   def electric?
    is_electric
  end

  def combustion?
    !is_electric
  end

  def hybrid?
    fuel_type == "hybrid"
  end

  def has_telemetry?
    vehicle_provider_mappings.active.any?
  end

  def active_telemetry_provider
    vehicle_provider_mappings.active.first&.integration_provider
  end

  def needs_maintenance?
    return false unless next_maintenance_date
    next_maintenance_date <= Date.current
  end

  def days_until_maintenance
    return nil unless next_maintenance_date
    (next_maintenance_date - Date.current).to_i
  end

  def total_km_driven
    return 0 unless initial_odometer_km && current_odometer_km
    current_odometer_km - initial_odometer_km
  end

  def update_odometer!(new_odometer)
    update!(current_odometer_km: new_odometer) if new_odometer > (current_odometer_km || 0)
  end

  def full_name
    parts = [ brand, model, license_plate ].compact
    parts.join(" - ")
  end

  def display_name
    "#{name} (#{license_plate})"
  end

  def self.fuel_types
    %w[diesel gasoline electric hybrid lpg cng hydrogen]
  end

  def self.vehicle_types
    %w[car van truck motorcycle bus]
  end

  def self.statuses
    %w[active maintenance inactive sold]
  end

  private

  def normalize_license_plate
    self.license_plate = license_plate&.upcase&.strip
  end

  def set_is_electric_flag
    self.is_electric = (fuel_type == "electric")
  end

  def normalize_vin
    self.vin = vin&.upcase&.strip if vin.present?
  end
end
