# app/api/v1/marketplace.rb
module V1
  class MarketplaceApi < Grape::API
    resource :marketplace do
      desc "Obtener marketplace de integraciones (categorías y proveedores)" do
        detail "Endpoint flexible que retorna el marketplace completo o filtrado según parámetros"
      end
      params do
        # Filtros de visualización
        optional :view, type: String,
                 values: %w[grouped flat category_detail],
                 default: "grouped",
                 desc: "Modo de visualización: grouped (categorías), flat (lista), category_detail (una categoría)"

        # Filtros de categoría
        optional :category_slug, type: String,
                 desc: "Filtrar por slug de categoría (ej: telemetry)"

        # Filtros de proveedores
        optional :provider_status, type: String,
                 values: %w[active beta coming_soon],
                 desc: "Filtrar proveedores por estado"

        optional :is_premium, type: Boolean,
                 desc: "Filtrar solo proveedores premium (true) o gratuitos (false)"

        optional :search, type: String,
                 desc: "Buscar por nombre de proveedor o categoría"

        # Opciones de inclusión
        optional :include_features, type: Boolean,
                 default: true,
                 desc: "Incluir features de cada proveedor"

        optional :include_auth_info, type: Boolean,
                 default: false,
                 desc: "Incluir información de autenticación"

        optional :include_stats, type: Boolean,
                 default: false,
                 desc: "Incluir estadísticas de uso"
      end
      get do
        result = Integrations::Marketplace::UnifiedMarketplaceService.new(
          view: params[:view],
          category_slug: params[:category_slug],
          provider_status: params[:provider_status],
          is_premium: params[:is_premium],
          search: params[:search],
          include_features: params[:include_features],
          include_auth_info: params[:include_auth_info],
          include_stats: params[:include_stats]
        ).call

        if result.success?
          # Adaptar la respuesta según el view mode
          case params[:view]
          when "grouped"
            present result.data[:categories],
                    with: Entities::MarketplaceCategoryEntity,
                    include_features: params[:include_features],
                    include_auth_info: params[:include_auth_info]

          when "flat"
            present result.data[:providers],
                    with: Entities::MarketplaceProviderEntity,
                    include_features: params[:include_features],
                    include_auth_info: params[:include_auth_info],
                    include_stats: params[:include_stats]

          when "category_detail"
            present result.data[:category],
                    with: Entities::MarketplaceCategoryEntity,
                    include_features: params[:include_features],
                    include_auth_info: params[:include_auth_info]
          end
        else
          error!({
            error: "marketplace_error",
            message: result.errors.join(", ")
          }, 500)
        end
      end

      desc "Obtener detalle completo de un proveedor específico"
      params do
        requires :slug, type: String, desc: "Slug del proveedor (ej: geotab)"
        optional :include_category, type: Boolean, default: true
        optional :include_features, type: Boolean, default: true
        optional :include_auth_info, type: Boolean, default: true
        optional :include_stats, type: Boolean, default: true
      end
      get "providers/:slug" do
        provider = IntegrationProvider
          .for_marketplace
          .includes(:integration_category, :integration_features, :integration_auth_schema)
          .find_by!(slug: params[:slug])

        present provider,
                with: Entities::MarketplaceProviderEntity,
                include_category: params[:include_category],
                include_features: params[:include_features],
                include_auth_info: params[:include_auth_info],
                include_stats: params[:include_stats]
      rescue ActiveRecord::RecordNotFound
        error!({
          error: "not_found",
          message: "Proveedor no encontrado"
        }, 404)
      end

      desc "Obtener formulario completo para configurar un proveedor"
      params do
        requires :slug, type: String, desc: "Slug del proveedor"
      end
      get "providers/:slug/configuration_form" do
        provider = IntegrationProvider
          .for_marketplace
          .includes(:integration_features, :integration_auth_schema)
          .find_by!(slug: params[:slug])

        unless provider.integration_auth_schema&.is_active
          error!({
            error: "configuration_unavailable",
            message: "Este proveedor no tiene configuración de autenticación disponible"
          }, 422)
        end

        present provider, with: Entities::ConfigurationFormEntity
      rescue ActiveRecord::RecordNotFound
        error!({
          error: "not_found",
          message: "Proveedor no encontrado"
        }, 404)
      end

      desc "Obtener lista de empresas/tenants disponibles"
      params do
        optional :exclude_configured_for, type: String,
                 desc: "Excluir tenants que ya tienen este proveedor configurado"
      end
      get "available_tenants" do
        tenants = Tenant.active.order(:name)

        if params[:exclude_configured_for].present?
          provider = IntegrationProvider.find_by(slug: params[:exclude_configured_for])

          if provider
            configured_tenant_ids = TenantIntegrationConfiguration
              .where(integration_provider: provider)
              .pluck(:tenant_id)

            tenants = tenants.where.not(id: configured_tenant_ids)
          end
        end

        present tenants, with: Entities::TenantSummaryEntity
      end

      desc "Configurar una integración desde el marketplace"
      params do
        requires :tenant_id, type: Integer
        requires :provider_slug, type: String
        requires :credentials, type: Hash
        requires :enabled_features, type: Array[String]
        optional :sync_frequency, type: String, values: %w[daily weekly monthly], default: "daily"
        optional :sync_hour, type: Integer, values: 0..23, default: 2
        optional :sync_day_of_week, type: Integer, values: 0..6
        optional :sync_day_of_month, type: String, values: %w[start end]
        optional :test_connection_first, type: Boolean, default: false
        optional :activate_immediately, type: Boolean, default: false
      end
      post "setup" do
        tenant = Tenant.find(params[:tenant_id])

        result = Integrations::Marketplace::SetupIntegrationService.new(
          tenant,
          params[:provider_slug],
          declared(params, include_missing: false).except(:tenant_id, :provider_slug)
        ).call

        if result.success?
          present result.data,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true,
                  include_provider: true,
                  include_features: true
        else
          error!({
            error: "setup_failed",
            message: result.errors.join(", ")
          }, 422)
        end
      rescue ActiveRecord::RecordNotFound
        error!({
          error: "tenant_not_found",
          message: "Empresa/Tenant no encontrada"
        }, 404)
      end

      desc "Probar conexión con un proveedor sin crear configuración"
      params do
        requires :provider_slug, type: String
        requires :credentials, type: Hash
      end
      post "test_connection" do
        provider = IntegrationProvider.for_marketplace.find_by!(slug: params[:provider_slug])

        result = Integrations::TenantConfigurations::TestConnectionService.new(
          provider.id,
          params[:credentials]
        ).call

        if result.success?
          present result.data, with: Entities::ConnectionTestResultEntity
        else
          error!({
            error: "connection_failed",
            message: result.errors.join(", ")
          }, 422)
        end
      rescue ActiveRecord::RecordNotFound
        error!({
          error: "provider_not_found",
          message: "Proveedor no encontrado"
        }, 404)
      end
    end
  end
end

# app/api/v1/sync_executions.rb
module V1
  class SyncExecutionsApi < Grape::API
    helpers do
      def current_tenant
        @current_tenant ||= Tenant.find(params[:tenant_id])
      end
    end

    resource :tenants do
      route_param :tenant_id do
        resource :integration_configurations do
          route_param :config_id do
            desc "Ejecutar sincronización manual de una feature" do
              detail "Obtiene datos del proveedor de telemetría y los normaliza"
              success Entities::SyncResultEntity
              failure [ [ 401, "No autorizado" ], [ 422, "Error de validación" ] ]
            end

            params do
              requires :feature_key,
                       type: String,
                       values: %w[fuel battery trips real_time_location],
                       desc: "Feature a sincronizar",
                       documentation: {
                         example: "fuel"
                       }
            end

            post "sync" do
              # Buscar configuración
              config = current_tenant
                .tenant_integration_configurations
                .find(params[:config_id])

              # Verificar que esté activa
              unless config.is_active
                error!({
                  error: "inactive_configuration",
                  message: "La configuración debe estar activa para sincronizar"
                }, 422)
              end

              # Verificar que la feature esté habilitada
              unless config.feature_enabled?(params[:feature_key])
                error!({
                  error: "feature_not_enabled",
                  message: "La feature '#{params[:feature_key]}' no está habilitada",
                  enabled_features: config.enabled_features
                }, 422)
              end

              # Ejecutar sincronización
              result = Integrations::Sync::SyncExecutionService.new(
                config,
                params[:feature_key],
                manual: true
              ).call

              if result.success?
                # Respuesta exitosa
                present result.data, with: Entities::SyncResultEntity
              else
                # Error en sincronización
                error!({
                  error: "sync_error",
                  message: result.errors.join(", "),
                  execution_id: result.data&.dig(:execution_id)
                }, 422)
              end
            end

            desc "Sincronizar todas las features habilitadas" do
              detail "Ejecuta sincronización para cada feature activa en secuencia"
            end

            post "sync_all" do
              config = current_tenant
                .tenant_integration_configurations
                .find(params[:config_id])

              unless config.is_active
                error!({
                  error: "inactive_configuration",
                  message: "La configuración debe estar activa"
                }, 422)
              end

              if config.enabled_features.empty?
                error!({
                  error: "no_features_enabled",
                  message: "No hay features habilitadas para sincronizar"
                }, 422)
              end

              # Ejecutar sync para cada feature
              results = []

              config.enabled_features.each do |feature_key|
                result = Integrations::Sync::SyncExecutionService.new(
                  config,
                  feature_key,
                  manual: true
                ).call

                results << {
                  feature_key: feature_key,
                  success: result.success?,
                  execution_id: result.data&.dig(:execution_id),
                  message: result.success? ? result.message : result.errors.join(", "),
                  data: result.success? ? result.data : nil
                }
              end

              # Retornar resumen
              {
                total_features: results.count,
                successful: results.count { |r| r[:success] },
                failed: results.count { |r| !r[:success] },
                results: results
              }
            end

            desc "Listar historial de sincronizaciones" do
              detail "Muestra las ejecuciones pasadas con sus estadísticas"
            end

            params do
              optional :feature_key,
                       type: String,
                       desc: "Filtrar por feature"
              optional :status,
                       type: String,
                       values: %w[running completed failed],
                       desc: "Filtrar por estado"
              optional :limit,
                       type: Integer,
                       default: 50,
                       values: 1..100,
                       desc: "Número de registros"
            end

            get "sync_executions" do
              config = current_tenant
                .tenant_integration_configurations
                .find(params[:config_id])

              # Construir query
              executions = config.integration_sync_executions.recent

              # Aplicar filtros
              if params[:feature_key]
                executions = executions.by_feature(params[:feature_key])
              end

              if params[:status]
                executions = executions.where(status: params[:status])
              end

              executions = executions.limit(params[:limit])

              # Retornar
              present executions,
                      with: Entities::IntegrationSyncExecutionSummaryEntity
            end

            desc "Ver detalle de una ejecución de sincronización"

            params do
              requires :execution_id, type: Integer
            end

            get "sync_executions/:execution_id" do
              config = current_tenant
                .tenant_integration_configurations
                .find(params[:config_id])

              execution = config
                .integration_sync_executions
                .find(params[:execution_id])

              present execution,
                      with: Entities::IntegrationSyncExecutionEntity,
                      include_computed: true
            end

            desc "Obtener estadísticas de sincronización"

            get "sync_statistics" do
              config = current_tenant
                .tenant_integration_configurations
                .find(params[:config_id])

              stats = {
                # Estadísticas de ejecuciones
                total_executions: config.integration_sync_executions.count,
                completed: config.integration_sync_executions.completed.count,
                failed: config.integration_sync_executions.failed.count,
                running: config.integration_sync_executions.running.count,

                # Estadísticas de datos RAW
                total_raw_records: config.integration_raw_data.count,
                pending_records: config.integration_raw_data.pending.count,
                normalized_records: config.integration_raw_data.normalized.count,
                failed_records: config.integration_raw_data.failed.count,
                duplicate_records: config.integration_raw_data.duplicate.count,

                # Timestamps
                last_sync_at: config.last_sync_at,
                last_sync_status: config.last_sync_status,

                # Agrupaciones
                by_feature: config.integration_sync_executions
                  .group(:feature_key).count,
                by_status: config.integration_sync_executions
                  .group(:status).count
              }

              present stats, with: Entities::SyncStatisticsEntity
            end
          end
        end
      end
    end
  end
end


# app/api/v1/integration_configurations_api.rb (MEJORADA)
module V1
  class IntegrationConfigurationsApi < Grape::API
    resource :integration_configurations do
      desc "Listar configuraciones de integraciones"
      params do
        optional :tenant_id, type: Integer, desc: "Filtrar por tenant"
        optional :provider_slug, type: String, desc: "Filtrar por proveedor"
        optional :is_active, type: Boolean, desc: "Filtrar por estado activo"
        optional :status, type: String, values: %w[success error], desc: "Filtrar por último estado de sync"
        optional :page, type: Integer, default: 1
        optional :per_page, type: Integer, default: 50, values: 1..100
      end
      get do
        configs = TenantIntegrationConfiguration.includes(:integration_provider, :tenant)

        # Aplicar filtros
        configs = configs.where(tenant_id: params[:tenant_id]) if params[:tenant_id]
        configs = configs.where(is_active: params[:is_active]) unless params[:is_active].nil?
        configs = configs.where(last_sync_status: params[:status]) if params[:status]

        if params[:provider_slug]
          configs = configs.joins(:integration_provider)
            .where(integration_providers: { slug: params[:provider_slug] })
        end

        # Ordenar
        configs = configs.order(created_at: :desc)

        # Paginación
        total = configs.count
        configs = configs.offset((params[:page] - 1) * params[:per_page])
                        .limit(params[:per_page])

        {
          configurations: Entities::TenantIntegrationConfigurationSummaryEntity.represent(configs),
          pagination: {
            current_page: params[:page],
            per_page: params[:per_page],
            total_items: total,
            total_pages: (total.to_f / params[:per_page]).ceil
          }
        }
      end

      desc "Obtener detalle completo de una configuración"
      params do
        requires :id, type: Integer
      end
      get ":id" do
        config = TenantIntegrationConfiguration.find(params[:id])

        present config,
                with: Entities::TenantIntegrationConfigurationEntity,
                include_provider: true,
                include_tenant: true,
                include_features: true,
                include_computed: true
      end

      # Bloque 1: Actualizar Credenciales
      desc "Actualizar solo las credenciales de autenticación"
      params do
        requires :id, type: Integer
        requires :credentials, type: Hash, desc: "Nuevas credenciales"
        optional :test_connection_after, type: Boolean, default: false,
                 desc: "Probar conexión después de actualizar"
      end
      put ":id/credentials" do
        config = TenantIntegrationConfiguration.find(params[:id])

        # Si está activa, desactivar temporalmente
        was_active = config.is_active
        config.update!(is_active: false) if was_active

        # Actualizar credenciales
        if config.update(credentials: params[:credentials])
          # Limpiar estado de última sincronización
          config.update(last_sync_status: nil, last_sync_error: nil)

          # Probar conexión si se solicita
          if params[:test_connection_after]
            test_result = Integrations::TenantConfigurations::TestConnectionService.new(
              config.integration_provider.id,
              params[:credentials]
            ).call

            unless test_result.success?
              error!({
                error: "connection_test_failed",
                message: "Credenciales actualizadas pero el test de conexión falló: #{test_result.errors.join(', ')}",
                config: Entities::TenantIntegrationConfigurationEntity.represent(
                  config, include_computed: true
                )
              }, 422)
            end
          end

          # Re-activar si estaba activa
          config.update!(is_active: true) if was_active

          present config,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true,
                  include_provider: true
        else
          error!({
            error: "validation_error",
            message: config.errors.full_messages.join(", ")
          }, 422)
        end
      end

      # Bloque 2: Actualizar Features
      desc "Actualizar features habilitadas"
      params do
        requires :id, type: Integer
        requires :enabled_features, type: Array[String], desc: "Lista de feature keys a habilitar"
      end
      put ":id/features" do
        config = TenantIntegrationConfiguration.find(params[:id])

        # Validar que todas las features existan
        available_features = config.integration_provider.integration_features.active.pluck(:feature_key)
        invalid_features = params[:enabled_features] - available_features

        if invalid_features.any?
          error!({
            error: "invalid_features",
            message: "Features no disponibles: #{invalid_features.join(', ')}",
            available_features: available_features
          }, 422)
        end

        if config.update(enabled_features: params[:enabled_features])
          present config,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true,
                  include_features: true
        else
          error!({
            error: "validation_error",
            message: config.errors.full_messages.join(", ")
          }, 422)
        end
      end

      # Bloque 3: Actualizar Programación
      desc "Actualizar configuración de programación de sincronización"
      params do
        requires :id, type: Integer
        requires :sync_frequency, type: String, values: %w[daily weekly monthly]
        requires :sync_hour, type: Integer, values: 0..23
        optional :sync_day_of_week, type: Integer, values: 0..6
        optional :sync_day_of_month, type: String, values: %w[start end]
      end
      put ":id/schedule" do
        config = TenantIntegrationConfiguration.find(params[:id])

        update_params = {
          sync_frequency: params[:sync_frequency],
          sync_hour: params[:sync_hour],
          sync_day_of_week: params[:sync_day_of_week],
          sync_day_of_month: params[:sync_day_of_month]
        }

        if config.update(update_params)
          present config,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true
        else
          error!({
            error: "validation_error",
            message: config.errors.full_messages.join(", ")
          }, 422)
        end
      end

      # Actualización completa (mantener por compatibilidad)
      desc "Actualizar configuración completa"
      params do
        requires :id, type: Integer
        optional :credentials, type: Hash
        optional :enabled_features, type: Array[String]
        optional :sync_frequency, type: String, values: %w[daily weekly monthly]
        optional :sync_hour, type: Integer, values: 0..23
        optional :sync_day_of_week, type: Integer, values: 0..6
        optional :sync_day_of_month, type: String, values: %w[start end]
        optional :sync_config, type: Hash
      end
      put ":id" do
        config = TenantIntegrationConfiguration.find(params[:id])

        result = Integrations::TenantConfigurations::UpdateService.new(
          config,
          declared(params, include_missing: false)
        ).call

        if result.success?
          present result.data,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true,
                  include_provider: true
        else
          error!({
            error: "validation_error",
            message: result.errors.join(", ")
          }, 422)
        end
      end

      desc "Activar configuración"
      params do
        requires :id, type: Integer
      end
      post ":id/activate" do
        config = TenantIntegrationConfiguration.find(params[:id])

        result = Integrations::TenantConfigurations::ActivateService.new(config).call

        if result.success?
          present result.data,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true
        else
          error!({
            error: "activation_error",
            message: result.errors.join(", ")
          }, 422)
        end
      end

      desc "Desactivar configuración"
      params do
        requires :id, type: Integer
      end
      post ":id/deactivate" do
        config = TenantIntegrationConfiguration.find(params[:id])

        result = Integrations::TenantConfigurations::DeactivateService.new(config).call

        if result.success?
          present result.data,
                  with: Entities::TenantIntegrationConfigurationEntity,
                  include_computed: true
        else
          error!({
            error: "deactivation_error",
            message: result.errors.join(", ")
          }, 422)
        end
      end

       desc "Re-probar conexión de una configuración existente"
      params do
        requires :id, type: Integer
        optional :use_new_credentials, type: Hash,
                 desc: "Probar con credenciales diferentes sin guardarlas"
      end
      post ":id/test_connection" do
        config = TenantIntegrationConfiguration.find(params[:id])

        # Usar credenciales de prueba o las actuales
        credentials_to_test = params[:use_new_credentials] || config.credentials

        result = Integrations::TenantConfigurations::TestConnectionService.new(
          config.integration_provider.id,
          credentials_to_test
        ).call

        if result.success?
          present result.data, with: Entities::ConnectionTestResultEntity
        else
          error!({
            error: "connection_failed",
            message: result.errors.join(", ")
          }, 422)
        end
      end

      desc "Ejecutar sincronización manual de una feature específica"
      params do
        requires :id, type: Integer
        requires :feature_key, type: String,
                 values: %w[fuel battery trips real_time_location odometer diagnostics],
                 desc: "Feature a sincronizar"
      end
      post ":id/sync" do
        config = TenantIntegrationConfiguration.find(params[:id])

        # Verificar que esté activa
        unless config.is_active
          error!({
            error: "inactive_configuration",
            message: "La configuración debe estar activa para sincronizar"
          }, 422)
        end

        # Verificar que la feature esté habilitada
        unless config.feature_enabled?(params[:feature_key])
          error!({
            error: "feature_not_enabled",
            message: "La feature '#{params[:feature_key]}' no está habilitada en esta configuración",
            enabled_features: config.enabled_features
          }, 422)
        end

        # Ejecutar sincronización
        result = Integrations::Sync::SyncExecutionService.new(
          config,
          params[:feature_key],
          manual: true
        ).call

        if result.success?
          present result.data, with: Entities::SyncResultEntity
        else
          error!({
            error: "sync_error",
            message: result.errors.join(", "),
            execution_id: result.data&.dig(:execution_id)
          }, 422)
        end
      end

      # Sincronizar todas las features habilitadas
      desc "Ejecutar sincronización de TODAS las features habilitadas"
      params do
        requires :id, type: Integer
      end
      post ":id/sync_all" do
        config = TenantIntegrationConfiguration.find(params[:id])

        unless config.is_active
          error!({
            error: "inactive_configuration",
            message: "La configuración debe estar activa para sincronizar"
          }, 422)
        end

        if config.enabled_features.empty?
          error!({
            error: "no_features_enabled",
            message: "No hay features habilitadas para sincronizar"
          }, 422)
        end

        # Ejecutar sync para cada feature
        results = []
        config.enabled_features.each do |feature_key|
          result = Integrations::Sync::SyncExecutionService.new(
            config,
            feature_key,
            manual: true
          ).call

          results << {
            feature_key: feature_key,
            success: result.success?,
            execution_id: result.data&.dig(:execution_id),
            message: result.success? ? result.message : result.errors.join(", ")
          }
        end

        {
          total_features: results.count,
          successful: results.count { |r| r[:success] },
          failed: results.count { |r| !r[:success] },
          results: results
        }
      end

      desc "Eliminar configuración de integración"
      params do
        requires :id, type: Integer
      end
      delete ":id" do
        config = TenantIntegrationConfiguration.find(params[:id])

        result = Integrations::TenantConfigurations::DestroyService.new(config).call

        if result.success?
          { success: true, message: result.message }
        else
          error!({
            error: "deletion_error",
            message: result.errors.join(", ")
          }, 422)
        end
      end

      desc "Obtener estadísticas de sincronización de una configuración"
      params do
        requires :id, type: Integer
      end
      get ":id/statistics" do
        config = TenantIntegrationConfiguration.find(params[:id])

        {
          configuration_id: config.id,
          provider: {
            name: config.integration_provider.name,
            slug: config.integration_provider.slug
          },
          sync_statistics: config.sync_statistics,
          enabled_features: config.enabled_features,
          is_active: config.is_active,
          last_sync_at: config.last_sync_at,
          last_sync_status: config.last_sync_status,
          sync_schedule: config.sync_schedule_description
        }
      end

      desc "Obtener historial de sincronizaciones"
      params do
        requires :id, type: Integer
        optional :feature_key, type: String
        optional :status, type: String, values: %w[running completed failed]
        optional :limit, type: Integer, default: 50
      end
      get ":id/sync_history" do
        config = TenantIntegrationConfiguration.find(params[:id])

        executions = config.integration_sync_executions.recent
        executions = executions.by_feature(params[:feature_key]) if params[:feature_key]
        executions = executions.where(status: params[:status]) if params[:status]
        executions = executions.limit(params[:limit])

        present executions, with: Entities::IntegrationSyncExecutionSummaryEntity
      end

      desc "Obtener opciones disponibles para programación"
      get "schedule_options" do
        present({}, with: Entities::SyncScheduleOptionsEntity)
      end
    end
  end
end

# app/api/v1/tenants.rb
module V1
  class TenantsApi < Grape::API
    helpers do
      # Helper para autenticación admin (ajustar según tu sistema)
      def require_admin!
        # Implementar lógica de autenticación admin
        # error!({ error: "unauthorized" }, 401) unless current_user&.admin?
      end
    end

    resource :tenants do
      desc "Listar todos los tenants (clientes)"
      params do
        optional :status, type: String, values: %w[active suspended trial], desc: "Filtrar por estado"
        optional :search, type: String, desc: "Buscar por nombre o email"
        optional :page, type: Integer, default: 1
        optional :per_page, type: Integer, default: 50, values: 1..100
        optional :include_integrations, type: Boolean, default: false
        optional :include_counts, type: Boolean, default: true
      end
      get do
        # require_admin! # Descomentar para requerir permisos admin

        tenants = Tenant.all

        # Filtros
        tenants = tenants.where(status: params[:status]) if params[:status]

        if params[:search].present?
          search_term = "%#{params[:search]}%"
          tenants = tenants.where(
            "name ILIKE :term OR email ILIKE :term OR slug ILIKE :term",
            term: search_term
          )
        end

        # Ordenar
        tenants = tenants.order(created_at: :desc)

        # Paginación
        total = tenants.count
        tenants = tenants.offset((params[:page] - 1) * params[:per_page])
                        .limit(params[:per_page])

        # Presentar
        {
          tenants: Entities::TenantEntity.represent(
            tenants,
            include_integrations: params[:include_integrations],
            include_counts: params[:include_counts],
            include_computed: true
          ),
          pagination: {
            current_page: params[:page],
            per_page: params[:per_page],
            total_items: total,
            total_pages: (total.to_f / params[:per_page]).ceil
          }
        }
      end
      desc "Obtener detalle de un tenant"
      params do
        requires :id, type: Integer, desc: "ID del tenant"
        optional :include_integrations, type: Boolean, default: true
        optional :include_statistics, type: Boolean, default: true
      end
      get ":id" do
        tenant = Tenant.find(params[:id])

        entity_options = {
          include_integrations: params[:include_integrations],
          include_counts: true,
          include_computed: true
        }

        result = Entities::TenantEntity.represent(tenant, entity_options).as_json

        # Agregar estadísticas si se solicitan
        if params[:include_statistics]
          result[:statistics] = {
            total_vehicles: tenant.vehicles.count,
            active_vehicles: tenant.vehicles.active.count,
            total_refuelings: VehicleRefueling.by_tenant(tenant.id).count,
            total_charges: VehicleElectricCharge.by_tenant(tenant.id).count,
            last_sync: tenant.tenant_integration_configurations.active.maximum(:last_sync_at)
          }
        end

        result
      end
      desc "Crear nuevo tenant (cliente)"
      params do
        requires :name, type: String, desc: "Nombre del tenant"
        requires :email, type: String, desc: "Email de contacto"
        optional :slug, type: String, desc: "Slug único (se genera automáticamente si no se proporciona)"
        optional :status, type: String, values: %w[active suspended trial], default: "trial"
        optional :settings, type: Hash, default: {}, desc: "Configuración personalizada"
      end
      post do
        # require_admin!

        tenant = Tenant.new(declared(params, include_missing: false))

        if tenant.save
          present tenant,
                  with: Entities::TenantEntity,
                  include_computed: true
        else
          error!({
            error: "validation_error",
            message: tenant.errors.full_messages.join(", "),
            details: tenant.errors.messages
          }, 422)
        end
      end
      desc "Actualizar tenant"
      params do
        requires :id, type: Integer
        optional :name, type: String
        optional :email, type: String
        optional :status, type: String, values: %w[active suspended trial]
        optional :settings, type: Hash
      end
      put ":id" do
        # require_admin!

        tenant = Tenant.find(params[:id])

        if tenant.update(declared(params, include_missing: false))
          present tenant,
                  with: Entities::TenantEntity,
                  include_computed: true
        else
          error!({
            error: "validation_error",
            message: tenant.errors.full_messages.join(", ")
          }, 422)
        end
      end
      desc "Eliminar tenant"
      params do
        requires :id, type: Integer
        optional :force, type: Boolean, default: false, desc: "Forzar eliminación incluso con datos"
      end
      delete ":id" do
        # require_admin!

        tenant = Tenant.find(params[:id])

        # Verificar si tiene datos asociados
        if !params[:force] && tenant.has_associated_data?
          error!({
            error: "tenant_has_data",
            message: "El tenant tiene datos asociados. Use force=true para eliminar de todas formas.",
            data: {
              vehicles_count: tenant.vehicles.count,
              configurations_count: tenant.tenant_integration_configurations.count,
              refuelings_count: VehicleRefueling.by_tenant(tenant.id).count,
              charges_count: VehicleElectricCharge.by_tenant(tenant.id).count
            }
          }, 422)
        end

        if tenant.destroy
          { success: true, message: "Tenant eliminado exitosamente" }
        else
          error!({
            error: "deletion_error",
            message: tenant.errors.full_messages.join(", ")
          }, 422)
        end
      end
      desc "Activar tenant"
      params do
        requires :id, type: Integer
      end
      post ":id/activate" do
        # require_admin!

        tenant = Tenant.find(params[:id])
        tenant.update!(status: "active")

        present tenant,
                with: Entities::TenantEntity,
                include_computed: true
      end
      desc "Suspender tenant"
      params do
        requires :id, type: Integer
      end
      post ":id/suspend" do
        # require_admin!

        tenant = Tenant.find(params[:id])
        tenant.update!(status: "suspended")

        # Desactivar todas sus integraciones
        tenant.tenant_integration_configurations.active.update_all(is_active: false)

        present tenant,
                with: Entities::TenantEntity,
                include_computed: true
      end
      desc "Obtener estadísticas detalladas del tenant"
      params do
        requires :id, type: Integer
        optional :from_date, type: Date, desc: "Fecha desde"
        optional :to_date, type: Date, desc: "Fecha hasta"
      end
      get ":id/statistics" do
        tenant = Tenant.find(params[:id])

        from_date = params[:from_date] || 30.days.ago
        to_date = params[:to_date] || Date.current

        {
          tenant_id: tenant.id,
          tenant_name: tenant.name,
          period: {
            from: from_date,
            to: to_date
          },
          vehicles: {
            total: tenant.vehicles.count,
            active: tenant.vehicles.active.count,
            with_telemetry: tenant.vehicles_with_telemetry.count
          },
          integrations: {
            total: tenant.tenant_integration_configurations.count,
            active: tenant.tenant_integration_configurations.active.count,
            by_provider: tenant.tenant_integration_configurations
              .joins(:integration_provider)
              .group("integration_providers.name")
              .count
          },
          refuelings: {
            total: VehicleRefueling.by_tenant(tenant.id)
              .between_dates(from_date, to_date).count,
            total_liters: VehicleRefueling.by_tenant(tenant.id)
              .between_dates(from_date, to_date)
              .sum(:volume_liters).to_f.round(2),
            total_cost: VehicleRefueling.by_tenant(tenant.id)
              .between_dates(from_date, to_date)
              .sum(:cost).to_f.round(2)
          },
          electric_charges: {
            total: VehicleElectricCharge.by_tenant(tenant.id)
              .between_dates(from_date, to_date).count,
            total_kwh: VehicleElectricCharge.by_tenant(tenant.id)
              .between_dates(from_date, to_date)
              .sum(:energy_consumed_kwh).to_f.round(2)
          },
          syncs: {
            total_executions: IntegrationSyncExecution
              .joins(:tenant_integration_configuration)
              .where(tenant_integration_configurations: { tenant_id: tenant.id })
              .where("started_at BETWEEN ? AND ?", from_date, to_date)
              .count,
            successful: IntegrationSyncExecution
              .joins(:tenant_integration_configuration)
              .where(tenant_integration_configurations: { tenant_id: tenant.id })
              .where("started_at BETWEEN ? AND ?", from_date, to_date)
              .completed.count
          }
        }
      end
      desc "Estadísticas globales de todos los tenants"
      get "stats" do
        # require_admin!

        {
          total_tenants: Tenant.count,
          by_status: Tenant.group(:status).count,
          active_tenants: Tenant.active.count,
          total_vehicles: Vehicle.count,
          total_integrations: TenantIntegrationConfiguration.count,
          active_integrations: TenantIntegrationConfiguration.active.count,
          total_refuelings: VehicleRefueling.count,
          total_charges: VehicleElectricCharge.count,
          most_active_tenants: Tenant
            .joins(:tenant_integration_configurations)
            .group("tenants.id", "tenants.name")
            .select("tenants.id, tenants.name, COUNT(tenant_integration_configurations.id) as integrations_count")
            .order("integrations_count DESC")
            .limit(10)
            .map { |t| { id: t.id, name: t.name, integrations_count: t.integrations_count } }
        }
      end
    end
  end
end


# app/api/v1/vehicle_electric_charges.rb
module V1
  class VehicleElectricChargesApi < Grape::API
    helpers do
      def current_tenant
        @current_tenant ||= Tenant.find(params[:tenant_id])
      end
    end

    resource :tenants do
      route_param :tenant_id do
        resource :vehicles do
          route_param :vehicle_id do
            resource :electric_charges do
              desc "Listar cargas eléctricas de un vehículo"
              params do
                optional :from_date, type: Date
                optional :to_date, type: Date
                optional :charge_type, type: String, values: %w[AC DC]
                optional :limit, type: Integer, default: 100
              end
              get do
                vehicle = current_tenant.vehicles.find(params[:vehicle_id])

                charges = vehicle.vehicle_electric_charges.recent

                if params[:from_date] && params[:to_date]
                  charges = charges.between_dates(params[:from_date], params[:to_date])
                end

                charges = charges.where(charge_type: params[:charge_type]) if params[:charge_type]
                charges = charges.limit(params[:limit])

                present charges,
                        with: Entities::VehicleElectricChargeEntity,
                        include_computed: true
              end
              desc "Detalle de una carga eléctrica"
              params do
                requires :id, type: Integer
              end
              get ":id" do
                vehicle = current_tenant.vehicles.find(params[:vehicle_id])
                charge = vehicle.vehicle_electric_charges.find(params[:id])

                present charge,
                        with: Entities::VehicleElectricChargeEntity,
                        include_computed: true,
                        include_raw_data: true
              end
            end
          end
        end
        resource :electric_charges do
          desc "Listar todas las cargas eléctricas del tenant"
          params do
            optional :from_date, type: Date
            optional :to_date, type: Date
            optional :vehicle_id, type: Integer
            optional :charge_type, type: String, values: %w[AC DC]
            optional :limit, type: Integer, default: 100
          end
          get do
            charges = VehicleElectricCharge.by_tenant(current_tenant.id).recent

            if params[:from_date] && params[:to_date]
              charges = charges.between_dates(params[:from_date], params[:to_date])
            end

            charges = charges.by_vehicle(params[:vehicle_id]) if params[:vehicle_id]
            charges = charges.where(charge_type: params[:charge_type]) if params[:charge_type]
            charges = charges.limit(params[:limit])

            present charges, with: Entities::VehicleElectricChargeSummaryEntity
          end
        end
      end
    end
  end
end

# app/api/v1/vehicle_provider_mappings.rb
module V1
  class VehicleProviderMappingsApi < Grape::API
    helpers do
      def current_tenant
        @current_tenant ||= Tenant.find(params[:tenant_id])
      end
    end

    resource :tenants do
      route_param :tenant_id do
        resource :integration_configurations do
          route_param :config_id do
            resource :vehicle_mappings do
              desc "Listar mapeos de vehículos para una configuración"
              params do
                optional :active_only, type: Boolean, default: false
              end
              get do
                config = current_tenant.tenant_integration_configurations.find(params[:config_id])
                mappings = config.vehicle_provider_mappings
                mappings = mappings.active if params[:active_only]

                present mappings, with: Entities::VehicleProviderMappingEntity
              end
              desc "Crear mapeo entre vehículo y proveedor"
              params do
                requires :vehicle_id, type: Integer
                requires :external_vehicle_id, type: String
                optional :external_vehicle_name, type: String
                optional :is_active, type: Boolean, default: true
                optional :external_metadata, type: Hash, default: {}
              end
              post do
                config = current_tenant.tenant_integration_configurations.find(params[:config_id])
                vehicle = current_tenant.vehicles.find(params[:vehicle_id])

                result = Integrations::VehicleMappings::CreateMappingService.new(
                  config,
                  vehicle,
                  params[:external_vehicle_id],
                  params[:external_vehicle_name]
                ).call

                if result.success?
                  present result.data, with: Entities::VehicleProviderMappingEntity
                else
                  error!({ error: "validation_error", message: result.errors.join(", ") }, 422)
                end
              end
              desc "Actualizar mapeo"
              params do
                requires :id, type: Integer
                optional :external_vehicle_name, type: String
                optional :external_metadata, type: Hash
              end
              put ":id" do
                config = current_tenant.tenant_integration_configurations.find(params[:config_id])
                mapping = config.vehicle_provider_mappings.find(params[:id])

                if mapping.update(declared(params, include_missing: false))
                  present mapping, with: Entities::VehicleProviderMappingEntity
                else
                  error!({ error: "validation_error", message: mapping.errors.full_messages.join(", ") }, 422)
                end
              end
              desc "Activar mapeo"
              params do
                requires :id, type: Integer
              end
              post ":id/activate" do
                config = current_tenant.tenant_integration_configurations.find(params[:config_id])
                mapping = config.vehicle_provider_mappings.find(params[:id])

                mapping.activate!
                present mapping, with: Entities::VehicleProviderMappingEntity
              end
              desc "Desactivar mapeo"
              params do
                requires :id, type: Integer
              end
              post ":id/deactivate" do
                config = current_tenant.tenant_integration_configurations.find(params[:config_id])
                mapping = config.vehicle_provider_mappings.find(params[:id])

                mapping.deactivate!
                present mapping, with: Entities::VehicleProviderMappingEntity
              end
              desc "Eliminar mapeo"
              params do
                requires :id, type: Integer
              end
              delete ":id" do
                config = current_tenant.tenant_integration_configurations.find(params[:config_id])
                mapping = config.vehicle_provider_mappings.find(params[:id])

                if mapping.destroy
                  { success: true, message: "Mapeo eliminado exitosamente" }
                else
                  error!({ error: "deletion_error", message: mapping.errors.full_messages.join(", ") }, 422)
                end
              end
            end
          end
        end
      end
    end
  end
end

# app/api/v1/vehicle_refuelings.rb
module V1
  class VehicleRefuelingsApi < Grape::API
    helpers do
      def current_tenant
        @current_tenant ||= Tenant.find(params[:tenant_id])
      end
    end

    resource :tenants do
      route_param :tenant_id do
        resource :vehicles do
          route_param :vehicle_id do
            resource :refuelings do
              desc "Listar repostajes de un vehículo"
              params do
                optional :from_date, type: Date
                optional :to_date, type: Date
                optional :limit, type: Integer, default: 100
              end
              get do
                vehicle = current_tenant.vehicles.find(params[:vehicle_id])

                refuelings = vehicle.vehicle_refuelings.recent

                if params[:from_date] && params[:to_date]
                  refuelings = refuelings.between_dates(params[:from_date], params[:to_date])
                end

                refuelings = refuelings.limit(params[:limit])

                present refuelings,
                        with: Entities::VehicleRefuelingEntity,
                        include_computed: true
              end
              desc "Detalle de un repostaje"
              params do
                requires :id, type: Integer
              end
              get ":id" do
                vehicle = current_tenant.vehicles.find(params[:vehicle_id])
                refueling = vehicle.vehicle_refuelings.find(params[:id])

                present refueling,
                        with: Entities::VehicleRefuelingEntity,
                        include_computed: true,
                        include_raw_data: true
              end
            end
          end
        end
        resource :refuelings do
          desc "Listar todos los repostajes del tenant"
          params do
            optional :from_date, type: Date
            optional :to_date, type: Date
            optional :vehicle_id, type: Integer
            optional :fuel_type, type: String
            optional :limit, type: Integer, default: 100
          end
          get do
            refuelings = VehicleRefueling.by_tenant(current_tenant.id).recent

            if params[:from_date] && params[:to_date]
              refuelings = refuelings.between_dates(params[:from_date], params[:to_date])
            end

            refuelings = refuelings.by_vehicle(params[:vehicle_id]) if params[:vehicle_id]
            refuelings = refuelings.by_fuel_type(params[:fuel_type]) if params[:fuel_type]
            refuelings = refuelings.limit(params[:limit])

            present refuelings, with: Entities::VehicleRefuelingSummaryEntity
          end
        end
      end
    end
  end
end

# app/api/v1/vehicles.rb
module V1
  class VehiclesApi < Grape::API
    helpers do
      def current_tenant
        @current_tenant ||= Tenant.find(params[:tenant_id])
      end
    end

    resource :tenants do
      route_param :tenant_id do
        resource :vehicles do
          desc "Listar vehículos del tenant"
          params do
            optional :status, type: String, values: Vehicle.statuses
            optional :fuel_type, type: String, values: Vehicle.fuel_types
            optional :vehicle_type, type: String, values: Vehicle.vehicle_types
            optional :is_electric, type: Boolean
            optional :with_telemetry, type: Boolean, default: false
          end
          get do
            vehicles = current_tenant.vehicles

            vehicles = vehicles.where(status: params[:status]) if params[:status]
            vehicles = vehicles.by_fuel_type(params[:fuel_type]) if params[:fuel_type]
            vehicles = vehicles.where(vehicle_type: params[:vehicle_type]) if params[:vehicle_type]
            vehicles = vehicles.where(is_electric: params[:is_electric]) unless params[:is_electric].nil?

            if params[:with_telemetry]
              vehicles = current_tenant.vehicles_with_telemetry
            end

            vehicles = vehicles.by_name

            present vehicles, with: Entities::VehicleEntity
          end
          desc "Obtener detalle de un vehículo"
          params do
            requires :id, type: Integer
          end
          get ":id" do
            vehicle = current_tenant.vehicles.find(params[:id])
            present vehicle,
                    with: Entities::VehicleEntity,
                    include_telemetry: true,
                    include_statistics: true
          end
          desc "Crear vehículo"
          params do
            requires :name, type: String
            requires :license_plate, type: String
            optional :vin, type: String
            optional :brand, type: String
            optional :model, type: String
            optional :year, type: Integer
            optional :vehicle_type, type: String, values: Vehicle.vehicle_types
            optional :fuel_type, type: String, values: Vehicle.fuel_types
            optional :tank_capacity_liters, type: Float
            optional :battery_capacity_kwh, type: Float
            optional :initial_odometer_km, type: Float
            optional :acquisition_date, type: Date
            optional :metadata, type: Hash, default: {}
          end
          post do
            vehicle = current_tenant.vehicles.build(declared(params, include_missing: false))

            if vehicle.save
              present vehicle, with: Entities::VehicleEntity
            else
              error!({ error: "validation_error", message: vehicle.errors.full_messages.join(", ") }, 422)
            end
          end
          desc "Actualizar vehículo"
          params do
            requires :id, type: Integer
            optional :name, type: String
            optional :license_plate, type: String
            optional :vin, type: String
            optional :brand, type: String
            optional :model, type: String
            optional :year, type: Integer
            optional :vehicle_type, type: String
            optional :fuel_type, type: String
            optional :status, type: String, values: Vehicle.statuses
            optional :tank_capacity_liters, type: Float
            optional :battery_capacity_kwh, type: Float
            optional :current_odometer_km, type: Float
            optional :last_maintenance_date, type: Date
            optional :next_maintenance_date, type: Date
            optional :metadata, type: Hash
          end
          put ":id" do
            vehicle = current_tenant.vehicles.find(params[:id])

            if vehicle.update(declared(params, include_missing: false))
              present vehicle, with: Entities::VehicleEntity
            else
              error!({ error: "validation_error", message: vehicle.errors.full_messages.join(", ") }, 422)
            end
          end
          desc "Eliminar vehículo"
          params do
            requires :id, type: Integer
          end
          delete ":id" do
            vehicle = current_tenant.vehicles.find(params[:id])

            if vehicle.destroy
              { success: true, message: "Vehículo eliminado exitosamente" }
            else
              error!({ error: "deletion_error", message: vehicle.errors.full_messages.join(", ") }, 422)
            end
          end
        end
      end
    end
  end
end
